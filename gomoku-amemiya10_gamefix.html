<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>五目並べ (AI アメミヤチカ対戦版)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* 画面全体にキャンバスを広げ、スクロールバーを非表示にする */
        body { 
            font-family: 'Inter', sans-serif; 
            margin: 0;
            overflow: hidden;
            background-color: #f3f4f6;
        }

        /* 雨のエフェクト用キャンバス */
        #rainCanvas {
            display: none; /* 初期状態では非表示 */
            position: fixed;
            top: 0;
            left: 0;
            z-index: 40; /* ゲームUIの上に配置 */
            pointer-events: none; /* クリックイベントを下に透過させる */
            opacity: 0.8;
            transition: opacity 1s;
        }
        
        /* 盤面コンテナのスタイル */
        .board-grid {
            width: min(80vmin, 350px); 
            height: min(80vmin, 350px);
            aspect-ratio: 1 / 1; 
            background-color: #F8D395; /* 碁盤の色 */
            border: 4px solid #4a2d10;
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.3);
            margin: 0 auto; 
            border-radius: 8px;
            position: relative; 
            --interval: calc(100% / 14); 
            /* 碁盤の線を描画 */
            background-image: 
                linear-gradient(to right, #7D4C28 1px, transparent 1px),
                linear-gradient(to bottom, #7D4C28 1px, transparent 1px),
                radial-gradient(circle at center, #7D4C28 4px, transparent 5px); 
            background-repeat: repeat, repeat, no-repeat; 
            background-size: var(--interval) var(--interval);
            background-position: 
                0 0, 
                0 0, 
                calc(var(--interval) * 7) calc(var(--interval) * 7); 
        }

        /* 石のスタイル */
        .cell {
            position: absolute;
            /* 15x15のグリッドの中心に合わせるため、幅/高さを調整 */
            width: calc(100% / 15); 
            height: calc(100% / 15);
            cursor: pointer;
            z-index: 10;
        }
        .piece {
            position: absolute;
            width: 90%; 
            height: 90%;
            border-radius: 50%;
            pointer-events: none; 
            box-shadow: 0 0 0 0px transparent, 0 1px 3px rgba(0, 0, 0, 0.4);
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0); 
            animation: placePiece 0.15s forwards; 
        }

        .piece-black { background-color: #000; }
        .piece-white { background-color: #fff; border: 1px solid #444; }

        @keyframes placePiece {
            from { transform: translate(-50%, -50%) scale(0); }
            to { transform: translate(-50%, -50%) scale(1); }
        }
        
        .last-move {
            /* 赤い枠の修正としてbox-shadowを使用 */
            box-shadow: 0 0 0 3px rgba(255, 0, 0, 0.8), 0 1px 3px rgba(0, 0, 0, 0.4);
        }
        
        .winning-piece {
            box-shadow: 0 0 10px 4px gold, 0 1px 3px rgba(0, 0, 0, 0.8);
        }

        /* キャラクターとメッセージエリアのスタイル調整 */
        #character-and-message {
            max-width: min(90vw, 450px); 
            width: 100%; 
            margin: 0 auto;
            height: 300px; 
            display: flex; 
            justify-content: center;
            align-items: flex-end; 
            padding-bottom: 0; 
            position: relative; 
        }
        
        /* 画像コンテナのスタイル */
        #char-image-container {
            position: relative; 
            height: 300px; 
            width: auto; 
            display: flex;
            justify-content: center;
            align-items: flex-end;
            overflow: visible; 
        }

        /* キャラクター画像 */
        #char-image {
            width: 100%; 
            max-height: 300px !important; 
            object-fit: contain; 
            position: relative; 
            z-index: 15;      
            opacity: 1;       
            transition: opacity 0.3s;
            min-width: 100px; 
        }

        /* --- モバイルでのレイアウト調整 --- */
        @media (max-width: 768px) {
            
            #character-and-message {
                flex-direction: column; 
                height: auto; 
                max-height: 40vh; 
                max-width: 100%; 
                padding: 0 1rem;
            }
            
            #char-image-container {
                 height: 150px; 
                 order: 1; 
                 width: auto;
            }
            #char-image {
                max-height: 150px !important; 
                width: auto !important; 
                margin-top: 10px;
            }
            
            #speech-bubble {
                position: relative !important; 
                width: 90% !important;
                transform: none !important; 
                margin-top: 10px;
                margin-bottom: 10px;
                left: 0 !important; 
                order: 0; 
            }
        }
    </style>

    <script>
        // ゲーム定数 
        const BOARD_SIZE = 15;
        const PLAYER_HUMAN = 1; 
        const PLAYER_AI = 2;    
        const AI_NAME = "アメミヤチカ"; 
        const TURN_TIME_LIMIT = 10; 
        
        // --- 疲弊モード設定 ---
        const FATIGUE_THRESHOLD = 25; // 25手で疲弊モードに入る
        const FATIGUE_ERROR_CHANCE = 0.50; // 50%の確率で最善手以外の手を打つ 

        // AIの評価値
        const SCORE_WEIGHTS = { 0: 0, 1: 1, 2: 10, 3: 10000, 4: 1000000, 5: 10000000 };
        const IMAGE_BASE_URL = "https://raw.githubusercontent.com/kakinoki-meisaku/gomoku-game/main/assets/images/amemiya_";
        
        // 相手の勝利阻止（即座の5連ブロック）のスコア
        const BLOCK_BONUS = 15000000; 
        // 勝利スコア (最優先: 5連になった場合)
        const WIN_SCORE = SCORE_WEIGHTS[5] * 2; // 20,000,000 
        // 活四 (両辺空き) スコア - 勝利より少し低いが、ブロックより高い
        const OPEN_FOUR_WIN_SCORE = 19000000; // 19,000,000
        
        // --- ランダムメッセージリスト ---
        const RANDOM_MESSAGES = {
            // 活四または双活三による勝確時
            WIN_CONFIRMED: [
                "勝った！気がする！",
                "ふふふ、えへへへ",
                "命乞いをしなさい！"
            ],
            // 単一の四連によるリーチ時
            REACH: [
                "リーチかも～",
                "なんとかなるなる～",
                "そこでいいのかなー"
            ],
            // 疲労モード突入時のアナウンス
            FATIGUE_START: [
                "疲れてきちゃったなぁ...",
                "ねむい～...",
                "まだやるのー？"
            ]
        };

        let board = [];
        let currentPlayer = PLAYER_HUMAN;
        let gameActive = true;
        // lastMoveを正確に保持することで、赤い枠の表示を安定させる
        let lastMove = null; 
        let timerInterval = null;
        let timeRemaining = TURN_TIME_LIMIT;
        let moveCount = 0; // 現在盤面にある石の総数
        
        // --- 疲労モード突入時メッセージ表示用フラグ ---
        let hasAnnouncedFatigue = false; 

        let statusElement;
        let boardElement;
        let timerElement;
        let thinkingIndicator;
        let charImageElement;
        let speechBubbleElement; 

        // --- 雨エフェクト用 グローバル変数 ---
        var W = window.innerWidth; 
        var H = window.innerHeight; 
        let rainCanvas;
        let rainCtx;
        let drops = [];
        let rainAnimationId = null;

        // --- 雨粒の設定 ---
        const DROP_COUNT = 80; 
        const DROP_COLOR = 'rgba(174, 194, 224, 0.7)'; 
        const DROP_LENGTH_MIN = 10;
        const DROP_LENGTH_MAX = 20;
        const DROP_SPEED_MIN = 5;
        const DROP_SPEED_MAX = 12;

        /**
         * 指定されたメッセージタイプからランダムなメッセージを取得
         * @param {string} type - 'WIN_CONFIRMED', 'REACH', 'FATIGUE_START'
         */
        function getRandomMessage(type) {
            const messages = RANDOM_MESSAGES[type];
            if (!messages || messages.length === 0) {
                return `[ERROR: No messages for ${type}]`;
            }
            const randomIndex = Math.floor(Math.random() * messages.length);
            return messages[randomIndex];
        }

        /**
         * 盤面の初期化とUIのセットアップ
         */
        document.addEventListener('DOMContentLoaded', () => {
            speechBubbleElement = document.getElementById('speech-bubble'); 
            statusElement = document.getElementById('status-text');
            timerElement = document.getElementById('timer');
            thinkingIndicator = document.getElementById('thinking-indicator'); 
            charImageElement = document.getElementById('char-image'); 
            boardElement = document.getElementById('board');
            rainCanvas = document.getElementById('rainCanvas');
            rainCtx = rainCanvas.getContext('2d');

            window.addEventListener('resize', () => {
                if (rainAnimationId !== null) {
                    initRain();
                }
            });

            initializeBoardUI();
            initializeGame();
            
            document.getElementById('reset-button').addEventListener('click', initializeGame);
        });
        
        // --- 雨エフェクト関連ロジック ---

        /**
         * Raindropクラス: 個々の雨粒の挙動を管理
         */
        class Raindrop {
            constructor() {
                this.reposition();
                this.y = Math.random() * H; 
            }

            reposition() {
                W = window.innerWidth; 
                H = window.innerHeight; 
                this.x = Math.random() * W;
                this.y = -20 - (Math.random() * 300);
                this.length = Math.random() * (DROP_LENGTH_MAX - DROP_LENGTH_MIN) + DROP_LENGTH_MIN;
                this.speed = Math.random() * (DROP_SPEED_MAX - DROP_SPEED_MIN) + DROP_SPEED_MIN;
                this.opacity = Math.random() * 0.5 + 0.2; 
            }

            fall() {
                this.y += this.speed;
                if (this.y > H) {
                    this.reposition();
                }
            }

            draw() {
                rainCtx.beginPath();
                rainCtx.strokeStyle = DROP_COLOR.replace('0.7', this.opacity.toFixed(2));
                rainCtx.lineWidth = 1.5;
                rainCtx.lineCap = 'round';
                rainCtx.moveTo(this.x, this.y);
                rainCtx.lineTo(this.x, this.y + this.length);
                rainCtx.stroke();
            }
        }

        /**
         * キャンバスサイズを調整し、雨粒を初期化/リセットする
         */
        function initRain() {
            W = window.innerWidth;
            H = window.innerHeight;
            rainCanvas.width = W;
            rainCanvas.height = H;
            
            drops = [];
            for (let i = 0; i < DROP_COUNT; i++) {
                drops.push(new Raindrop());
                drops[i].y = Math.random() * H; 
            }
        }

        function animateRain() {
            rainCtx.clearRect(0, 0, W, H);
            
            for (let i = 0; i < drops.length; i++) {
                drops[i].fall();
                drops[i].draw();
            }
            
            if (rainAnimationId !== null) {
                rainAnimationId = requestAnimationFrame(animateRain);
            }
        }

        function startRain() {
            if (rainAnimationId === null) {
                initRain(); 
                rainCanvas.style.display = 'block';
                rainAnimationId = requestAnimationFrame(animateRain);
            }
        }

        function stopRain() {
            if (rainAnimationId !== null) {
                cancelAnimationFrame(rainAnimationId);
                rainAnimationId = null;
                rainCanvas.style.display = 'none';
            }
        }

        // --- ゲーム本体ロジック ---
        
        /**
         * ゲーム状態を初期化
         */
        function initializeGame() {
            board = Array(BOARD_SIZE).fill(0).map(() => Array(BOARD_SIZE).fill(0));
            currentPlayer = PLAYER_HUMAN;
            gameActive = true;
            lastMove = null;
            moveCount = 0;
            hasAnnouncedFatigue = false; // フラグをリセット
            
            clearInterval(timerInterval);
            timeRemaining = TURN_TIME_LIMIT;
            
            if (timerElement) {
                timerElement.innerHTML = `持ち時間: <span class="text-lg font-extrabold">${TURN_TIME_LIMIT}</span> 秒`;
            }
            
            if (thinkingIndicator) thinkingIndicator.textContent = ""; 
            
            stopRain(); 
            setCharacterMood('normal'); 
            updateStatus(`対局開始！あなた（黒）のターンです。`);
            
            renderGame();
        }
        
        /**
         * キャラクターの表情を切り替える関数
         * @param {string} mood - 'normal', 'win', 'loss', 'thinking', 'smile', 'reach', 'tired'
         */
        function setCharacterMood(mood) {
            if (!charImageElement) return;

            let suffix = 'normal.png'; 

            if (mood === 'win') {
                suffix = 'win.png'; 
            } else if (mood === 'loss') {
                suffix = 'lose.png'; 
            } else if (mood === 'thinking') {
                suffix = 'think.png'; 
            } else if (mood === 'smile') {
                suffix = 'smile.png'; 
            } else if (mood === 'reach') { 
                suffix = 'reach01.png'; // リーチ演出用の画像
            } else if (mood === 'tired') { 
                suffix = 'tired.png'; 
            }
            
            const path = IMAGE_BASE_URL + suffix;
            
            charImageElement.onerror = () => {
                charImageElement.src = 'https://placehold.co/160x160/cccccc/333333?text=Char';
            };
            
            charImageElement.src = path;
        }

        
        function initializeBoardUI() {
            if (!boardElement) return;
            boardElement.innerHTML = '';
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    const cell = document.createElement('div');
                    cell.classList.add('cell');
                    cell.dataset.row = r;
                    cell.dataset.col = c;
                    
                    // 盤面の交点にセルを配置
                    const interval = 100 / (BOARD_SIZE - 1);
                    const leftPos = c * interval; 
                    const topPos = r * interval;
                    
                    cell.style.left = `${leftPos}%`;
                    cell.style.top = `${topPos}%`;
                    cell.style.transform = 'translate(-50%, -50%)'; 
                    
                    cell.addEventListener('click', () => handleCellClick(r, c));
                    boardElement.appendChild(cell);
                }
            }
        }
        
        function renderGame() {
            if (!boardElement || !timerElement || !thinkingIndicator) return;

            const cells = boardElement.querySelectorAll('.cell');
            cells.forEach(cell => {
                const r = parseInt(cell.dataset.row);
                const c = parseInt(cell.dataset.col);
                const player = board[r][c];

                // 以前の石のDOM要素を保持しているかに関わらず、毎回完全に再描画し、枠をリセット
                cell.innerHTML = ''; 
                
                if (player !== 0) {
                    const piece = document.createElement('div');
                    piece.classList.add('piece', player === PLAYER_HUMAN ? 'piece-black' : 'piece-white');
                    
                    // 最後の着手マーク (赤い枠) のロジックを修正
                    
                    if (lastMove && lastMove.r === r && lastMove.c === c) {
                        piece.classList.add('last-move');
                    }
                    
                    cell.appendChild(piece);
                }
            });

            if (!gameActive && lastMove) {
                // 勝利線ハイライト
                const winningCoords = findWinningLine(lastMove.r, lastMove.c, lastMove.player);
                if (winningCoords) {
                    highlightWinningLine(winningCoords);
                }
            }

            if (gameActive) {
                clearInterval(timerInterval);
                if (currentPlayer === PLAYER_HUMAN) {
                    // 人間のターンでは思考中インジケータを非表示
                    thinkingIndicator.textContent = ""; 
                    thinkingIndicator.style.display = 'none'; // DOM非表示
                    if (moveCount > 0) { 
                        startTimer();
                    } else {
                        timerElement.innerHTML = "最初の1手は時間無制限です";
                        timerElement.style.display = 'block'; // DOM表示
                    }
                } else {
                    // 修正: AIターン時はタイマーを非表示にし、思考中インジケータを表示
                    timerElement.style.display = 'none'; // DOM非表示
                    thinkingIndicator.style.display = 'block'; // DOM表示
                    // AIの思考開始
                    setTimeout(() => { if (gameActive) aiTurn(); }, 500); 
                }
            }
        }

        function highlightWinningLine(coords) {
            coords.forEach(([r, c]) => {
                const cell = document.querySelector(`.cell[data-row="${r}"][data-col="${c}"]`);
                if (cell) {
                    cell.querySelector('.piece')?.classList.add('winning-piece');
                }
            });
        }

        /**
         * 勝利した5つの石の座標を返す (checkWinの補助)
         */
        function findWinningLine(r, c, player) {
            const directions = [
                [0, 1], // 横
                [1, 0], // 縦
                [1, 1], // 右下斜め
                [1, -1] // 左下斜め
            ];
            
            for (const [dr, dc] of directions) {
                let line = [];
                let maxCount = 0;
                let winningStones = [];

                // 最後に置いた石(r, c)を含む9マス (5連ができる最大範囲) をチェック
                for (let i = -4; i <= 4; i++) {
                    const nr = r + i * dr;
                    const nc = c + i * dc;

                    if (nr >= 0 && nr < BOARD_SIZE && nc >= 0 && nc < BOARD_SIZE) {
                        if (board[nr][nc] === player) {
                            line.push([nr, nc]);
                        } else {
                            if (line.length > maxCount) {
                                maxCount = line.length;
                                winningStones = [...line];
                            }
                            line = [];
                        }
                    } else {
                         if (line.length > maxCount) {
                            maxCount = line.length;
                            winningStones = [...line];
                        }
                        line = [];
                    }
                }
                if (line.length > maxCount) {
                    maxCount = line.length;
                    winningStones = [...line];
                }

                if (maxCount >= 5) {
                    return winningStones.slice(0, 5);
                }
            }
            return null;
        }

        
        function startTimer() {
            if (!timerElement || !speechBubbleElement) return;

            timeRemaining = TURN_TIME_LIMIT;
            
            const statusDiv = speechBubbleElement;
            statusDiv.classList.remove('bg-red-400', 'bg-red-500', 'bg-red-600', 'shadow-red-400/80', 'shadow-red-500/80', 'shadow-red-600/80', 'animate-pulse');
            statusDiv.classList.add('bg-blue-500', 'shadow-blue-500/80'); 

            // 人間のターンではタイマーを表示
            timerElement.innerHTML = `残り時間: <span class="text-lg font-extrabold">${timeRemaining}</span> 秒`;
            timerElement.style.display = 'block'; // DOM表示

            timerInterval = setInterval(() => {
                timeRemaining--;
                
                timerElement.innerHTML = `残り時間: <span class="text-lg font-extrabold">${timeRemaining}</span> 秒`;

                statusDiv.classList.remove('bg-red-400', 'bg-red-500', 'bg-red-600', 'shadow-red-400/80', 'shadow-red-500/80', 'shadow-red-600/80', 'animate-pulse');
                statusDiv.classList.remove('bg-blue-500', 'shadow-blue-500/80'); 

                if (timeRemaining <= 0) {
                    clearInterval(timerInterval);
                    handleTimeOut();
                } else if (timeRemaining <= 3) {
                    if (timeRemaining === 3) {
                        statusDiv.classList.add('bg-red-400', 'shadow-red-400/80');
                    } else if (timeRemaining === 2) {
                        statusDiv.classList.add('bg-red-500', 'shadow-red-500/80');
                    } else if (timeRemaining === 1) {
                        statusDiv.classList.add('bg-red-600', 'shadow-red-600/80', 'animate-pulse');
                    }
                } else {
                     statusDiv.classList.add('bg-blue-500', 'shadow-blue-500/80'); 
                }
            }, 1000);
        }

        function handleTimeOut() {
            gameActive = false;
            stopRain();
            if (thinkingIndicator) thinkingIndicator.textContent = ""; 
            updateStatus(`【時間切れ】10秒以内に石を置けませんでした。${AI_NAME}（白）の勝ちです！`, 'loss'); 
        }

        function handleCellClick(r, c) {
            if (!gameActive || currentPlayer !== PLAYER_HUMAN) return;
            if (board[r][c] !== 0) return;
            
            if (thinkingIndicator) thinkingIndicator.textContent = "";

            clearInterval(timerInterval);
            // 修正: 人間からの着手は脅威ではないため、nullを渡す
            placePiece(r, c, PLAYER_HUMAN, null); 
        }

        // 修正: threatTypeパラメータを追加
        async function placePiece(r, c, player, threatType = null) {
            if (board[r][c] !== 0) {
                console.error(`Error: Tried to place piece at occupied cell (${r}, c).`);
                gameActive = false;
                updateStatus(`【エラー】無効な場所への着手が発生しました。ゲームをリセットしてください。`, 'draw');
                return;
            }
            
            board[r][c] = player;
            lastMove = { r, c, player };
            
            // 重要な修正: どちらのプレイヤーの着手でも、手数としてカウントする
            moveCount++; 
            
            if (thinkingIndicator) thinkingIndicator.textContent = ""; 

            if (checkWin(r, c, player)) {
                gameActive = false;
                stopRain(); 
                const winnerText = player === PLAYER_HUMAN ? `あなた（黒）` : `${AI_NAME}（白）`; 
                const statusType = player === PLAYER_HUMAN ? 'win' : 'loss';
                updateStatus(`【勝利】${winnerText}の勝ちです！`, statusType);
                renderGame(); 
            } else if (isDraw()) {
                gameActive = false;
                stopRain(); 
                updateStatus(`【引き分け】碁盤がすべて埋まりました。`, 'draw');
                renderGame(); 
            } else {
                // 修正: switchTurnにthreatTypeを渡す
                await switchTurn(threatType);
            }
        }

        // 修正: パラメータをisReachからthreatTypeに変更
        async function switchTurn(threatType = null) {
            currentPlayer = currentPlayer === PLAYER_HUMAN ? PLAYER_AI : PLAYER_HUMAN;
            renderGame();
            
            const turnText = currentPlayer === PLAYER_HUMAN ? `あなた（黒）` : `${AI_NAME}（白）`; 
            
            let message = `${turnText}のターンです。`;
            
            // --- 重要な修正: 25手目(AIの13手目)のターン開始時に疲労モードが開始するように判定を調整 ---
            // moveCountは直前の手(24手目)まで完了した状態。
            // 疲労モードは25手目からなので、moveCountが24の時に疲労モードであることを通知する
            const isFatigued = moveCount >= FATIGUE_THRESHOLD - 1; // 24手目完了時 (25手目開始時)
            
            if (gameActive) {
                // --- 疲労モード/雨エフェクトの制御 ---
                if (isFatigued) {
                    startRain(); 
                    setCharacterMood('tired');
                    
                    // 疲労モード突入時メッセージ
                    if (!hasAnnouncedFatigue) {
                        // 疲労メッセージをランダムに表示 (修正箇所)
                        const fatigueMsg = getRandomMessage('FATIGUE_START');
                        updateStatus(fatigueMsg, 'tired');
                        await new Promise(resolve => setTimeout(resolve, 1500));
                        hasAnnouncedFatigue = true;
                    }
                    
                    // AIターン時はメッセージを更新しない
                    if (currentPlayer === PLAYER_HUMAN) {
                        message = `(疲労モード) ${turnText}のターンです。`;
                    } else {
                        // 疲労モードだが、AIターンメッセージは表示する
                        message = `${AI_NAME}のターンです。`;
                    }
                } else {
                    stopRain();
                    hasAnnouncedFatigue = false; // 非疲労状態に戻ったらフラグをリセット
                    
                    // リーチ/勝確の状態を維持
                    if (threatType === 'reach' || threatType === 'win_confirmed') {
                         setCharacterMood('reach');
                         const threatName = threatType === 'reach' ? 'リーチ' : '勝確';
                         // 相手ターンでのメッセージもターン情報を含める
                         message = currentPlayer === PLAYER_HUMAN ? `【AIの${threatName}】あなたのターンです。` : `${AI_NAME}のターンです。`;
                    } else { 
                        setCharacterMood('normal');
                        // AIターン時はメッセージを更新
                        if (currentPlayer === PLAYER_AI) {
                             message = `${AI_NAME}のターンです。`;
                        }
                    }
                }
            } else {
                stopRain();
                setCharacterMood('normal');
            }
            
            // 脅威の種類に応じてupdateStatusを呼び出す
            if (threatType === 'win_confirmed') {
                 // メッセージはaiTurnで先に表示済みなので、ターン情報に切り替える
                 updateStatus(message, 'win_confirmed'); 
            } else if (threatType === 'reach') {
                 // メッセージはaiTurnで先に表示済みなので、ターン情報に切り替える
                 updateStatus(message, 'reach');
            } else {
                 // 疲労モードのアナウンスが終わり、人間のターンになったら通常のメッセージに戻す
                 updateStatus(message, isFatigued ? 'tired' : 'normal');
            }
            
            // 修正: AIターンでもメッセージは常に表示されるようにする
            statusElement.style.display = 'block'; 
            if(currentPlayer === PLAYER_AI) {
                 thinkingIndicator.textContent = ""; // 思考開始前にリセット
                 thinkingIndicator.style.display = 'block';
            } else {
                 thinkingIndicator.style.display = 'none';
            }
        }
        
        /**
         * ステータス表示の更新
         */
        function updateStatus(message, type = 'normal') {
            if (!statusElement || !speechBubbleElement) return; 
            
            statusElement.textContent = message;
            
            const statusDiv = speechBubbleElement;
            // 既存のカラークラスをリセット
            statusDiv.className = 'absolute z-20 md:w-80 w-[90%] p-3 rounded-xl shadow-2xl transition-colors duration-300 left-1/2 -translate-x-1/2 bottom-2 text-white';
            
            // 修正: AIターンでもメッセージボックスの高さが維持されるように、display操作とp-0/p-3操作を削除
            statusDiv.classList.add('p-3');
            statusElement.style.display = 'block';
            timerElement.style.display = currentPlayer === PLAYER_HUMAN ? 'block' : 'none';
            thinkingIndicator.style.display = currentPlayer === PLAYER_AI ? 'block' : 'none';


            if (type === 'win') { 
                statusDiv.classList.add('bg-green-500', 'shadow-green-500/80'); 
                setCharacterMood('loss'); // 相手が勝ったので、AIは負け顔
            } else if (type === 'loss') { 
                statusDiv.classList.add('bg-red-500', 'shadow-red-500/80');
                setCharacterMood('win'); // AIが勝ったので、AIは勝ち顔
                stopRain(); 
            } else if (type === 'draw') {
                statusDiv.classList.remove('text-white');
                statusDiv.classList.add('bg-yellow-400', 'text-gray-800', 'shadow-yellow-400/80');
                setCharacterMood('normal');
                stopRain(); 
            } else if (type === 'win_confirmed') { // 勝確演出の追加
                statusDiv.classList.add('bg-red-700', 'shadow-red-700/80');
                setCharacterMood('reach'); // リーチ画像を使用
            } else if (type === 'reach') {
                // AIのリーチ演出の色と表情を適用
                statusDiv.classList.add('bg-pink-600', 'shadow-pink-600/80');
                setCharacterMood('reach');
            } else if (type === 'tired') {
                 // 疲労モードの色と表情
                 statusDiv.classList.add('bg-gray-700', 'shadow-gray-700/80');
                 // setCharacterMood('tired') は switchTurnで制御されているため不要
            } else {
                statusDiv.classList.add('bg-blue-500', 'shadow-blue-500/80');
            }
        }
        
        // --- AIロジック ---

        /**
         * 勝利判定 (5連チェック)
         */
        function checkWin(r, c, player) {
            return findWinningLine(r, c, player) !== null;
        }

        /**
         * 連続する石の数を数える (評価関数用)
         */
        function countConsecutive(r, c, dr, dc, player) {
            let count = 0;
            let openEnds = 0;
            let blocked = 0;
            const opponent = 3 - player;

            let currentR = r + dr;
            let currentC = c + dc;
            while (currentR >= 0 && currentR < BOARD_SIZE && currentC >= 0 && currentC < BOARD_SIZE && board[currentR][currentC] === player) {
                count++;
                currentR += dr;
                currentC += dc;
            }

            if (currentR >= 0 && currentR < BOARD_SIZE && currentC >= 0 && currentC < BOARD_SIZE && board[currentR][currentC] === 0) {
                openEnds++;
            } else if (currentR < 0 || currentR >= BOARD_SIZE || currentC < 0 || currentC >= BOARD_SIZE || board[currentR][currentC] === opponent) {
                blocked++;
            }

            currentR = r - dr;
            currentC = c - dc;
            while (currentR >= 0 && currentR < BOARD_SIZE && currentC >= 0 && currentC < BOARD_SIZE && board[currentR][currentC] === player) {
                count++;
                currentR -= dr;
                currentC -= dc;
            }

            if (currentR >= 0 && currentR < BOARD_SIZE && currentC >= 0 && currentC < BOARD_SIZE && board[currentR][currentC] === 0) {
                openEnds++;
            } else if (currentR < 0 || currentR >= BOARD_SIZE || currentC < 0 || currentC >= BOARD_SIZE || board[currentR][currentC] === opponent) {
                blocked++;
            }
            
            // 最後に打った石を含める
            return { count: count + 1, openEnds, blocked: blocked > 0 };
        }

        /**
         * 特定の方向に置いた石のラインのスコアを計算
         */
        function getLineScore(r, c, dr, dc, player) {
            const result = countConsecutive(r, c, dr, dc, player);
            
            if (result.count >= 5) {
                return WIN_SCORE;
            }
            
            if (result.count === 4) {
                if (result.openEnds === 2) {
                    // 活四 (_〇〇〇〇_)
                    return OPEN_FOUR_WIN_SCORE; 
                }
                if (result.openEnds >= 1) {
                    // 片塞がり四 or 飛び四など (〇〇〇〇_)
                    return SCORE_WEIGHTS[4]; 
                }
            }
            
            if (result.count === 3) {
                if (result.openEnds === 2) {
                    return SCORE_WEIGHTS[3]; // 活三 (_〇〇〇_)
                }
                if (result.openEnds === 1) {
                    return SCORE_WEIGHTS[2]; // 眠三
                }
            }

            if (result.count === 2 && result.openEnds === 2) {
                return SCORE_WEIGHTS[1];
            }
            
            if (result.blocked || result.openEnds === 0) {
                return 0;
            }

            return 0;
        }
        
        /**
         * 特定の着手(r, c)が活四 (_〇〇〇〇_) を形成するかチェック
         * **演出判定専用 (勝確)**
         */
        function checkOpenFour(r, c, player) {
            // 仮想的に石を置く
            board[r][c] = player; 
            
            const directions = [
                [0, 1], [1, 0], [1, 1], [1, -1]
            ];
            
            for (const [dr, dc] of directions) {
                const result = countConsecutive(r, c, dr, dc, player);
                
                // 活四の判定: 4連で両端が空いている (_〇〇〇〇_)
                if (result.count === 4 && result.openEnds === 2) {
                    // 仮想的に置いた石を元に戻す
                    board[r][c] = 0; 
                    return true;
                }
            }
            
            // 仮想的に置いた石を元に戻す
            board[r][c] = 0; 
            return false;
        }
        
        /**
         * 特定の着手(r, c)が双活三 (2つ以上の活三) を形成するかチェック
         * **演出判定専用 (勝確)**
         */
        function checkDoubleOpenThree(r, c, player) {
            // 仮想的に石を置く
            board[r][c] = player; 
            
            const directions = [
                [0, 1], [1, 0], [1, 1], [1, -1]
            ];
            let openThreeCount = 0;
            
            for (const [dr, dc] of directions) {
                // countConsecutiveは(r,c)を含めた連続数を数える
                const result = countConsecutive(r, c, dr, dc, player);
                
                // 活三の判定: 3連で両端が空いている (_〇〇〇_)
                if (result.count === 3 && result.openEnds === 2) {
                    openThreeCount++;
                }
            }
            
            // 仮想的に置いた石を元に戻す
            board[r][c] = 0; 

            // 2つ以上の活三があれば双活三
            return openThreeCount >= 2;
        }


        /**
         * 着手後のマスが、勝確ではない単一の四連パターン（〇〇〇〇_、〇〇_〇〇、〇〇〇_〇）を形成するかチェック
         * **ユーザー要望に応じて、単一の四連パターン検出にロジックを修正**
         */
        function checkThreateningLine(r, c, player) {
            // 仮想的に石を置く
            board[r][c] = player; 
            const directions = [ [0, 1], [1, 0], [1, 1], [1, -1] ];
            const opponent = 3 - player;

            for (const [dr, dc] of directions) {
                // (r, c) を含む5マス区間をすべてチェック
                // i = -4 から 0: 5マス窓の開始位置を (r, c) から -4 から 0 の範囲でずらす
                for (let i = -4; i <= 0; i++) {
                    let p_count = 0;      // プレイヤーの石の数
                    let empty_count = 0;  // 空きマスの数
                    let opponent_found = false; // 相手の石がライン内にあるか

                    // 5マス窓をチェック
                    for (let j = 0; j < 5; j++) {
                        const cr = r + (i + j) * dr;
                        const cc = c + (i + j) * dc;

                        // 盤面外はブロックとして扱う
                        if (cr < 0 || cr >= BOARD_SIZE || cc < 0 || cc >= BOARD_SIZE) {
                            opponent_found = true;
                            break;
                        }
                        
                        const piece = board[cr][cc];
                        if (piece === player) {
                            p_count++;
                        } else if (piece === 0) {
                            empty_count++;
                        } else if (piece === opponent) {
                            opponent_found = true;
                            break; 
                        }
                    }

                    // 4つ石があり、空きが1つ、相手の石がない => 単一の四連脅威が成立
                    // これにより、〇〇〇〇_、〇〇_〇〇、〇〇〇_〇など、全ての4+1パターンを検出する
                    if (p_count === 4 && empty_count === 1 && !opponent_found) {
                        board[r][c] = 0; // 元に戻す
                        return true;
                    }
                }
            }

            board[r][c] = 0; // 元に戻す
            return false;
        }
        
        /**
         * 着手可能なマスのリストを取得 (探索範囲の最適化)
         */
        function getAvailableMoves() {
            const moves = [];
            const checkRange = 3; 
            
            const occupied = [];
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    if (board[r][c] !== 0) {
                        occupied.push({ r, c });
                    }
                }
            }

            const candidateCoords = new Set();
            
            if (occupied.length === 0) {
                // 最初の1手は中央付近
                const centerR = Math.floor(BOARD_SIZE / 2);
                const centerC = Math.floor(BOARD_SIZE / 2);
                for (let r = centerR - 1; r <= centerR + 1; r++) {
                    for (let c = centerC - 1; c <= centerC + 1; c++) {
                        if (r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE) {
                            moves.push({r, c});
                        }
                    }
                }
                return moves.length > 0 ? moves : [{r: centerR, c: centerC}];
            } else {
                occupied.forEach(({ r, c }) => {
                    for (let dr = -checkRange; dr <= checkRange; dr++) {
                        for (let dc = -checkRange; dc <= checkRange; dc++) {
                            const newR = r + dr;
                            const newC = c + dc;
                            
                            if (newR >= 0 && newR < BOARD_SIZE && newC >= 0 && newC < BOARD_SIZE && board[newR][newC] === 0) {
                                candidateCoords.add(`${newR},${newC}`);
                            }
                        }
                    }
                });
            }

            candidateCoords.forEach(coordStr => {
                const [r, c] = coordStr.split(',').map(Number);
                moves.push({ r, c });
            });

            // 盤面がほぼ埋まっている場合のフォールバック
            if (moves.length === 0 && moveCount < BOARD_SIZE * BOARD_SIZE) {
                for (let r = 0; r < BOARD_SIZE; r++) {
                    for (let c = 0; c < BOARD_SIZE; c++) {
                        if (board[r][c] === 0) {
                            moves.push({ r, c });
                            return moves; 
                        }
                    }
                }
            }

            return moves;
        }
        
        /**
         * 最善手を見つける (評価関数ベース)
         */
        function findBestMove(player) {
            const opponent = 3 - player;
            const availableMoves = getAvailableMoves();
            const scoredMoves = [];

            if (availableMoves.length === 0) {
                return [];
            }
            
            const directions = [
                [0, 1], [1, 0], [1, 1], [1, -1] 
            ];

            for (const move of availableMoves) {
                const { r, c } = move;
                let score = 0;
                
                // 1. 勝利判定（即座の勝ち）をチェック
                board[r][c] = player;
                if (checkWin(r, c, player)) {
                    board[r][c] = 0;
                    return [{ move: {r, c}, score: WIN_SCORE }]; 
                }
                board[r][c] = 0; 

                // 2. 相手の勝利阻止（即座の負けを回避）をチェック
                board[r][c] = opponent; // 仮想的に相手が打った場合
                if (checkWin(r, c, opponent)) {
                    board[r][c] = 0; 
                    score += BLOCK_BONUS; 
                }
                board[r][c] = 0; 
                
                // --- 防御評価の強化 (活四阻止) ---
                // 3. 相手の潜在的脅威の排除（活四阻止）
                board[r][c] = player; // 自分の手として
                let defenseScore = 0;
                board[r][c] = opponent; // 相手の視点でラインを評価
                for (const [dr, dc] of directions) {
                    const opponentLineScore = getLineScore(r, c, dr, dc, opponent);
                    defenseScore = Math.max(defenseScore, opponentLineScore);
                }
                board[r][c] = 0;
                
                // 相手の脅威をブロックする手を優先させるために、防御スコアを大きく加算
                score += defenseScore * 2; 
                
                // --- 攻撃評価 ---
                // 4. 自石の評価値の計算（攻撃スコア）
                board[r][c] = player;
                let selfScore = 0;
                for (const [dr, dc] of directions) {
                    selfScore += getLineScore(r, c, dr, dc, player);
                }
                
                board[r][c] = 0;
                
                score += selfScore;

                // 5. 中央に近いほどボーナス
                const center = Math.floor(BOARD_SIZE / 2);
                const distance = Math.max(Math.abs(r - center), Math.abs(c - center));
                score += (BOARD_SIZE - distance) * 5; 

                scoredMoves.push({ move: { r, c }, score });
            }

            scoredMoves.sort((a, b) => b.score - a.score);

            return scoredMoves;
        }

        async function aiTurn() { 
            if (!gameActive) { if (thinkingIndicator) thinkingIndicator.textContent = ""; return; } 

            // 1. 思考開始 
            if (thinkingIndicator) thinkingIndicator.textContent = "思考中..."; 
            
            setCharacterMood('thinking'); 

            await new Promise(resolve => setTimeout(resolve, 800 + Math.random() * 500)); 
            
            if (!gameActive) { if (thinkingIndicator) thinkingIndicator.textContent = ""; return; } 

            const scoredMoves = findBestMove(PLAYER_AI);
            
            if (scoredMoves.length === 0) {
                 if (thinkingIndicator) thinkingIndicator.textContent = "";
                 await switchTurn(null);
                 return;
            }

            let bestMove = scoredMoves[0]?.move;
            const topScore = scoredMoves[0]?.score || 0; 
            
            // --- 疲弊モード判定用のフラグ ---
            // 勝利手 (5連: 20M) のみ例外とする
            const isImmediateWin = topScore === WIN_SCORE; 
            
            // --- 疲弊モード判定とミスロジック (AIの着手が25手目以降かチェック) ---
            const moveNumberToPlay = moveCount + 1; // これから打つ手の総手数
            const isFatigued = moveNumberToPlay >= FATIGUE_THRESHOLD;
            let finalMove = bestMove;

            // 修正: 勝利手 (WIN_SCORE) のみミスから除外。それ以外の全ての最高の防御/攻撃手は50%でミスするようになる。
            if (isFatigued && !isImmediateWin && scoredMoves.length > 1) { 
                // 疲弊しており、かつ勝ち確定(5連)ではない場合のみミスをする
                if (Math.random() < FATIGUE_ERROR_CHANCE) { 
                    // 2番目に良い手を選択
                    finalMove = scoredMoves[1].move; 
                    console.log(`AI Fatigue: Chose 2nd best move. Error Chance: ${FATIGUE_ERROR_CHANCE}`);
                }
            }
            // --- 疲弊モード判定とミスロジック END ---

            // 2. リーチ/勝確判定と表情/メッセージ更新
            
            // 即時勝利判定 (演出はスキップされる)
            board[finalMove.r][finalMove.c] = PLAYER_AI; 
            const isFinalMoveImmediateWin = checkWin(finalMove.r, finalMove.c, PLAYER_AI);
            board[finalMove.r][finalMove.c] = 0; // 盤面を元に戻す

            
            // 演出に必要なパターンチェックを明示的に行う
            const isFinalMoveOpenFour = checkOpenFour(finalMove.r, finalMove.c, PLAYER_AI); // 活四 (_〇〇〇〇_)
            const isSingleFourThreat = checkThreateningLine(finalMove.r, finalMove.c, PLAYER_AI); // 〇〇〇〇_、〇〇_〇〇などの単一四連


            let threatType = null;

            // コアロジック: 活四である場合のみ勝確
            if (!isFinalMoveImmediateWin) { 
                if (isFinalMoveOpenFour) {
                    threatType = 'win_confirmed';
                } 
            }

            // 勝確ではない場合、単一四連パターン（リーチ）の判定
            // リーチの条件: 勝確ではない AND 単一四連がある AND 即時勝利ではない
            if (threatType !== 'win_confirmed' && isSingleFourThreat && !isFinalMoveImmediateWin) { 
                threatType = 'reach';
            }

            if (thinkingIndicator) thinkingIndicator.textContent = ""; 
            
            if (threatType === 'win_confirmed') {
                // 勝確メッセージをランダムに表示 (修正箇所)
                const winMsg = getRandomMessage('WIN_CONFIRMED');
                updateStatus(winMsg, 'win_confirmed'); 
                await new Promise(resolve => setTimeout(resolve, 800)); 
            } else if (threatType === 'reach') { 
                // リーチメッセージをランダムに表示 (修正箇所)
                const reachMsg = getRandomMessage('REACH');
                updateStatus(reachMsg, 'reach'); 
                await new Promise(resolve => setTimeout(resolve, 800)); 
            }
            
            if (!gameActive) { if (thinkingIndicator) thinkingIndicator.textContent = ""; return; } 

            // 3. 石を置く
            await placePiece(finalMove.r, finalMove.c, PLAYER_AI, threatType);
            
            // 4. スマイル（着手時）表示 
            if (gameActive) {
                // 疲労モードのチェックはswitchTurnで行うため、ここでは疲労モードかどうかを再チェック
                const isCurrentFatigued = (moveCount) >= FATIGUE_THRESHOLD;
                
                // 修正: 脅威演出がない場合、かつ疲労モードではない場合のみ笑顔を表示
                if (!threatType) {
                    if (!isCurrentFatigued) {
                        setCharacterMood('smile');
                        await new Promise(resolve => setTimeout(resolve, 500)); 
                    }
                    // 疲労モードの場合は、switchTurnで設定された 'tired' の表情を維持
                } else {
                     // 脅威の表情を維持
                    await new Promise(resolve => setTimeout(resolve, 500)); 
                }
            }
        }
        
        // --- 補助関数 ---

        function isDraw() { 
            return moveCount === BOARD_SIZE * BOARD_SIZE;
        }
        
    </script>
</head>
<body class="bg-gray-100 h-screen flex flex-col items-center justify-start py-2 px-2 font-sans overflow-hidden">
    
    <canvas id="rainCanvas"></canvas>

    <div id="game-container" class="max-w-4xl w-full flex flex-col items-center p-2 bg-white rounded-xl shadow-2xl h-full relative z-10">
        
        <div class="flex items-center justify-center space-x-2 w-full pt-1 pb-1 flex-shrink-0">
            </div>
        
        <div id="character-and-message" class="relative flex justify-center px-4 flex-shrink-0">
            
            <div id="char-image-container" class="relative">
                <img id="char-image" 
                    src="https://raw.githubusercontent.com/kakinoki-meisaku/gomoku-game/main/assets/images/amemiya_normal.png" 
                    alt="AIキャラクター アメミヤチカ" 
                    class="h-auto rounded-lg object-contain relative z-15"
                    style="min-width: 100px;">
            </div>

            <div id="speech-bubble" 
                 class="absolute z-20 md:w-80 w-[90%] p-3 rounded-xl shadow-2xl transition-colors duration-300
                 bg-blue-500 text-white shadow-blue-500/80
                 left-1/2 -translate-x-1/2 bottom-2">
                <p id="status-text" class="font-semibold text-sm">対局開始！あなた（黒）のターンです。</p>
                <p id="timer" class="text-sm mt-1">持ち時間: 10秒</p>
                <div id="thinking-indicator" class="w-full h-4 text-center text-white font-bold transition-opacity duration-300 text-xs mt-1">
                </div>
            </div>
        </div>

        <div id="game-area" class="flex w-full justify-center max-w-5xl flex-grow">
            
            <div id="board-wrapper" class="flex flex-col items-center max-w-full justify-center h-full">
                <div id="board" class="board-grid">
                    </div>
            </div>
        </div>

        <div class="flex justify-center w-full py-3 flex-shrink-0">
            <button id="reset-button" class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-6 rounded-full shadow-lg transition duration-150 ease-in-out transform hover:scale-105 active:scale-95 text-sm">
                リセット
            </button>
        </div>
    </div>
</body>
</html>