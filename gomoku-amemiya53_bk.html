<!DOCTYPE html>

<html lang="ja">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>アメミヤチカと五目ならべ)</title>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ENES4Q9772"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-ENES4Q9772');
</script>
<script src="https://cdn.tailwindcss.com"></script>
<style>
        /* 画面全体にキャンバスを広げ、スクロールバーを非表示にする */
        body { 
            font-family: 'Inter', sans-serif; 
            margin: 0;
            overflow: hidden;
            /* --- ゲーム画面の背景を background_white.png に変更 --- */
            background-image: url('https://raw.githubusercontent.com/kakinoki-meisaku/gomoku-game/main/assets/images/background_white.png');
            background-size: cover; /* スタート画面と同じ表示方法 */
            background-repeat: no-repeat;
            background-position: center;
        }

        /* 水玉のグラデーションの定義 */
        :root {
            /* 円のサイズを小さく、青い虹彩風のグラデーション、明度高め */
            --dot-gradient: radial-gradient(circle at center, 
                rgba(240, 250, 255, 0.4) 0%,      /* 中心: 非常に明るい（ハイライト） */
                rgba(100, 180, 255, 0.3) 10%,      /* 中間: 明るい青 */
                rgba(0, 50, 150, 0.2) 12%,        /* 濃い青（虹彩の縁） */
                transparent 15%                  /* 外側: 透明（水玉の終点） */
            );
        }

        /* 水玉のグラデーションと繰り返しパターンを定義するコンテナ */
        .gradient-polka-dots {
            position: fixed;
            inset: 0;
            z-index: 90; /* 最前面に配置 */
            display: flex;
            flex-direction: column;
            max-width: min(90vw, 450px); 
            width: 100%; 
            margin: 0 auto;
            justify-content: center;
            align-items: flex-end; 
            position: relative; 
            
            background-color: #FAFEFF; 
            overflow: hidden; /* アニメーションがコンテナ外に出るのを防ぐ */
            position: absolute; /* キャラクターの後ろに配置するため絶対配置 */
            
            /* 2層の背景（千鳥配置用） */
            background-image: 
                var(--dot-gradient),
                var(--dot-gradient);
            
            /* 繰り返しパターンのサイズは80px 160pxで維持 */
            background-size: 80px 160px, 80px 160px; 
            
            /* 初期位置: 奇数行(0 0)、偶数行(40px 80px) */
            background-position: 
                0 0, 40px 80px; 
            
            /* flowアニメーションのみを適用 */
            animation: flow 15s linear infinite;
            
            /* キャラクター画像よりも下に表示 */
            z-index: -1; 
        }

        /* flow: 全ての水玉を右に流すアニメーション */
        @keyframes flow {
            from { 
                background-position: 0 0, 40px 80px; 
            }
            to {
                background-position: -80px 0, -40px 80px; 
            }
        }


        /* --- NEW: タイトル画像のふわふわアニメーション --- */
        @keyframes float {
            0% { transform: translateY(0px); }
            50% { transform: translateY(-12px); }
            100% { transform: translateY(0px); }
        }
        #title-image {
            animation: float 3s ease-in-out infinite;
        }
        
        /* --- NEW: スタート画面のスタイル --- */
        #start-screen {
            position: fixed;
            inset: 0;
            z-index: 90; /* 最前面に配置 */
            display: flex;
            flex-direction: column;
            align-items: center;
            /* 修正点: 上下中央揃えに戻し、要素が上下に収まるようにする */
            justify-content: center;
            min-height: 100vh; /* 画面高さより小さくならないように保証 */
            
            /* 背景画像の設定 */
            background-image: url('https://raw.githubusercontent.com/kakinoki-meisaku/gomoku-game/main/assets/images/background.png');
            
            /* --- 💡 修正: モバイル版（縦長）のデフォルト設定 --- */
            /* 画面を覆い尽くし、横に隙間ができないようにする (上下は切れてもOK) */
            background-size: cover;
            
            background-repeat: no-repeat; /* 繰り返しを防止 */
            background-position: center;
            
            /* スライドアニメーション */
            transition: transform 0.7s ease-in-out;
            
            /* 💡 ボタン押下時の透過アニメーションのための背景色のオーバーレイ */
            background-color: rgba(255, 255, 255, 0.1); 
            backdrop-filter: blur(2px);
        }

        /* --- 💡 修正: ブラウザ版（横長）の設定 (769px以上で上書き) --- */
        @media (min-width: 769px) {
            #start-screen {
                /* PCなど横長の画面では、画像全体を表示し、上下左右に余白ができる設定 */
                background-size: contain; 
            }
        }
        /* --- 修正ここまで --- */

        #start-button {
            cursor: pointer;
            width: 33%;
            min-width: 150px;
            max-width: 300px;
            transition: transform 0.15s;
        }
        #start-button:hover {
            transform: scale(1.05);
        }
        #start-button:active {
            transform: scale(0.95);
        }

        /* 雨のエフェクト用キャンバス */
        #rainCanvas {
            display: none; /* 初期状態では非表示 */
            position: fixed;
            top: 0;
            left: 0;
            z-index: 40; /* ゲームUIの上に配置 */
            pointer-events: none; /* クリックイベントを下に透過させる */
            opacity: 0.8;
            transition: opacity 1s;
        }
        
        /* 盤面コンテナのスタイル */
        .board-grid {
            width: min(80vmin, 350px); 
            height: min(80vmin, 350px);
            aspect-ratio: 1 / 1; 
            background-color: #73C2FB; /* 碁盤の色 */
            border: 4px solid #4CA6E7;
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.3);
            margin: 0 auto; 
            border-radius: 8px;
            position: relative; 
            --interval: calc(100% / 14); 
            /* 碁盤の線を描画 */
            background-image: 
                linear-gradient(to right, #F4FBFE 1px, transparent 1px),
                linear-gradient(to bottom, #F4FBFE 1px, transparent 1px),
                radial-gradient(circle at center, #F4FBFE 4px, transparent 5px); 
            background-repeat: repeat, repeat, no-repeat; 
            background-size: var(--interval) var(--interval);
            background-position: 
                0 0, 
                0 0, 
                calc(var(--interval) * 7) calc(var(--interval) * 7); 
        }

        /* 石のスタイル */
        .cell {
            position: absolute;
            /* 15x15のグリッドの中心に合わせるため、幅/高さを調整 */
            width: calc(100% / 15); 
            height: calc(100% / 15);
            cursor: pointer;
            z-index: 20;
        }
        .piece {
            position: absolute;
            width: 90%; 
            height: 90%;
            /* 💡 修正: clip-pathを使って形状を強制的に円形にクリップする */
            clip-path: circle(50%); 
            /* 修正: border-radius: 50%; がbox-shadowを円形にするために必要 */
            border-radius: 50%; 
            pointer-events: none; 
            /* 影の初期値 (薄い影) */
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.4); 
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0); 
            animation: placePiece 0.15s forwards; 
            
            /* 画像調整 */
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
        }

        @keyframes placePiece {
            from { transform: translate(-50%, -50%) scale(0); }
            to { transform: translate(-50%, -50%) scale(1); }
        }
        
        /* 💡 新しいハイライト用のクラス (画像オーバーレイ方式) */
        .last-move-highlight {
            position: absolute;
            /* 石の大きさに合わせる */
            width: 90%; 
            height: 90%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            
            pointer-events: none;
            z-index: 30; /* 石(z-index: 20)の上に置く */
            
            /* 透過赤丸のSVG画像を背景に設定 */
            background-image: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='100%' height='100%' viewBox='0 0 100 100'><circle cx='50' cy='50' r='48' fill='none' stroke='%23FF4136' stroke-width='10' opacity='0.8'/></svg>");
            background-size: 100%;
            background-repeat: no-repeat;
        }
        
        .winning-piece {
            /* clip-pathとborder-radius: 50%により、この影が円形になる */
            box-shadow: 0 0 10px 4px gold, 0 1px 3px rgba(0, 0, 0, 0.8);
        }

        /* キャラクターとメッセージエリアのスタイル調整 */
        #character-and-message {
            max-width: min(90vw, 450px); 
            width: 100%; 
            margin: 0 auto;
            /* 修正済み: キャラクター領域を400pxに拡大 */
            height: 400px; 
            display: flex; 
            justify-content: center;
            align-items: flex-end; 
            padding-bottom: 0; 
            position: relative; 
        }
        
        /* 画像コンテナのスタイル */
        #char-image-container {
            position: relative; 
            /* 修正済み: キャラクター領域を400pxに拡大 */
            height: 400px; 
            width: auto; 
            display: flex;
            justify-content: center;
            align-items: flex-end;
            overflow: visible; 
        }

        /* キャラクター画像 */
        #char-image {
            width: 100%; 
            /* 修正済み: キャラクター画像を400pxに拡大 */
            max-height: 400px !important; 
            object-fit: contain; 
            position: relative; 
            z-index: 15;      
            opacity: 1;       
            transition: opacity 0.3s;
            min-width: 100px; 
        }
        
        /* --- NEW: スピーカーアイコンと設定メニューのスタイル --- */
        #audio-control-icon {
            position: absolute;
            top: 10px; /* キャラクターの上部に配置 */
            right: 10px; /* キャラクターの右側に配置 */
            z-index: 50; /* キャラクター画像より上 */
            cursor: pointer;
            padding: 8px;
            background-color: rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            transition: background-color 0.2s;
        }
        
        #audio-control-icon:hover {
            background-color: rgba(255, 255, 255, 1);
        }

        #audio-settings-menu {
            position: absolute;
            top: 40px; /* アイコンの下に配置 */
            right: 0px; 
            z-index: 55;
            width: 200px;
            padding: 12px;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            display: none; /* 初期状態では非表示 */
            flex-direction: column;
            gap: 10px;
        }
        
        #terushi {
            position:absolute;
            bottom: 180px !important; /* 高さの固定 */
            
            /* 横軸の中央寄せを確実に実行するための設定 */
            left: 0;
            right: 0;
            margin-left: auto;
            margin-right: auto;
  
            /* 以前の transform による位置調整は削除 */
            /* transform: translateX(-50%); */
  
            width: 100px !important;
            z-index:25;
            display:none;
            cursor:pointer;
            animation:terushi-float 3s ease-in-out infinite;
          }
          @keyframes terushi-float {
            0% { transform: translateY(0); }
            50% { transform: translateY(-6px);}
            100% { transform: translateY(0); }
          }



        /* --- モバイルでのレイアウト調整 --- */
        @media (max-width: 768px) {
            
            #character-and-message {
                /* 修正済み: キャラクターの高さを220pxに拡大 */
                height: auto !important; /* 高さを自動にし、制約を解除 */
                bottom: 0 !important;    /* 下からの位置指定を解除 */
                max-height: 220px; 
                max-width: 100%; 
                padding: 0 1rem;
                flex-direction: row; 
                align-items: flex-end;
            }
            
            #char-image-container {
                 /* 修正済み: 画像コンテナの高さを220pxに拡大 */
                 height: 250px; 
                 width: auto;
            }
            #char-image {
                /* 修正済み: キャラクター画像を220pxに拡大 */
                max-height: 250px !important; 
                width: auto !important; 
                margin-top: 10px;
            }
            
            #speech-bubble {
                position: absolute !important; 
                width: 80% !important;
                transform: translateX(-50%) !important; 
                margin-top: 0;
                margin-bottom: 0;
                left: 50% !important; 
                bottom: 2px !important; 
            }
            
            /* NEW: テルシーのモバイル版調整 (小さく、位置を低く) */
            #terushi {
                width: 60px !important;  /* サイズを小さくする (元の100pxから60pxへ) */
                bottom: 120px !important;  /* 位置を低くする (元の180pxから80pxへ) */
            }
            
            
            #audio-control-icon {
                top: 10px;  /* 修正: PC版(10px)から下に移動（値は適宜調整してください） */
                right: 10px; /* PC版と同じ値を維持 */
            }
        }

        /* --- 修正: ボードの上に重ねるボタンのスタイル --- */
        #board-wrapper {
             /* 必須: 子要素の絶対配置の基準とする */
            position: relative; 
        }

        #reset-button-container {
            /* 碁盤の上に重ねる */
            position: absolute; 
            /* ボードの中央に配置 */
            top: 50%; 
            left: 50%;
            /* コンテンツのサイズに応じて中央に補正 */
            transform: translate(-50%, -50%) scale(0.8);
            
            /* 修正: パディングを削減し、ボタンが改行しないように幅を狭める */
            padding: 20px 30px; 
            background-color: #fff;
            border-radius: 12px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
            text-align: center;
            opacity: 0;
            transition: transform 0.3s ease-out, opacity 0.3s ease-out;
            z-index: 60; /* 碁盤や雨エフェクトの上に配置 */
            pointer-events: none; /* 初期状態ではクリック透過 */
        }
        
        /* ボタン表示時のアニメーション */
        .show-reset-button {
            opacity: 1 !important;
            transform: translate(-50%, -50%) scale(1) !important;
            pointer-events: auto !important; /* 表示されたらクリック可能に */
        }

    

</style>
<script>
        // ゲーム定数 
        const BOARD_SIZE = 15;
        const PLAYER_HUMAN = 1; 
        const PLAYER_AI = 2;    
        const AI_NAME = "アメミヤチカ"; 
        const TURN_TIME_LIMIT = 10; 
        
        // --- 疲弊モード設定 ---
        const FATIGUE_THRESHOLD = 25; // 25手で疲弊モードに入る
        const FATIGUE_ERROR_CHANCE = 0.50; // 50%の確率で最善手以外の手を打つ 

        // --- 勝利時画像URL定義 ---
        const GOHOUBI_A_URL = "https://raw.githubusercontent.com/kakinoki-meisaku/gomoku-game/main/assets/images/gohoubi_A.png"; // 疲労モード前
        const GOHOUBI_B_URL = "https://raw.githubusercontent.com/kakinoki-meisaku/gomoku-game/main/assets/images/gohoubi_B.png"; // 疲労モード中

        // --- 音声関連の定数とグローバル変数 ---
        const VOICE_BASE_URL = "https://raw.githubusercontent.com/kakinoki-meisaku/gomoku-game/main/assets/voice/";

        // BGMのURLと音量
        const BGM_URL = "https://raw.githubusercontent.com/kakinoki-meisaku/gomoku-game/main/assets/audio/bgm_game.mp3";
        const BGM_VOLUME_DEFAULT = 0.20; // 20%の音量
        let gameBGM = null; // BGM用のAudioオブジェクト

        // 石を置く効果音の設定 
        const PIECE_PUT_SE_URL = "https://raw.githubusercontent.com/kakinoki-meisaku/gomoku-game/main/assets/audio/SE_pieces_on.mp3";
        const PIECE_PUT_SE_VOLUME_DEFAULT = 0.50; // 50%の音量
        
        // クリティカル効果音の設定
        const CRITICAL_SE_URL = "https://raw.githubusercontent.com/kakinoki-meisaku/gomoku-game/main/assets/audio/SE_critical.mp3";
        const CRITICALE_VOLUME_DEFAULT = 0.50; // 50%の音量
        
        // スタート/リセットボタンの効果音の設定を追加
        const PIKON_SE_URL = "https://raw.githubusercontent.com/kakinoki-meisaku/gomoku-game/main/assets/audio/SE_pikon.mp3";
        const PIKON_SE_VOLUME_DEFAULT = 0.50; // 50%の音量
        // ------------------------------------

        const VOICE_CHANCE_PUT = 0.30; // 石を置いた時の音声再生確率 30%

        // スタート画面用の音声 
        const START_VOICES = ["title_01_ame.mp3", "title_02_teru.mp3"];
        const START_BUTTON_VOICE = ["start_01.mp3", "start_02.mp3", "start_03.mp3", "start_04.mp3", "start_05.mp3", "start_06.mp3"] ;

        // 石を置いた時のランダム音声リスト
        const PUT_VOICES = [
            "put_01_ei.mp3",
            "put_02_poti.mp3",
            "put_03_torya.mp3",
            "put_04.mp3",
            "put_05.mp3",
            "put_06.mp3",
            "put_07.mp3",
            "put_08.mp3"
        ];
        
        // テルシーの音声リストを追加 ---
        const TETU_OK_VOICES = [
            "tetu_ok_01.mp3",
            "tetu_ok_02.mp3",
            "tetu_ok_03.mp3",
            "tetu_ok_04.mp3",
            "tetu_ok_05.mp3",
            "tetu_ok_06.mp3",
            "tetu_ok_07.mp3"
        ];
        
        const TETU_NG_VOICES = [
            "tetu_ng_01.mp3",
            "tetu_ng_02.mp3",
            "tetu_ng_03.mp3"
        ];
        
         // リーチされた音声リストを追加 ---
        const SHOCK_VOICES = [
            "shock_01.mp3",
            "shock_02.mp3",
            "shock_03.mp3",
            "shock_04.mp3",
            "shock_05.mp3",
            "shock_06.mp3",
            "shock_07.mp3",
            "shock_08.mp3",
            "shock_09.mp3",
        ];
        
        // ピンチ音声リストを追加 ---
        const PINCH_VOICES = [
            "pinch_01.mp3",
            "pinch_02.mp3",
            "pinch_03.mp3",
            "pinch_04.mp3",
            "pinch_05.mp3"
        ];
        

        // メッセージと対応する音声ファイル名
        const MESSAGE_VOICE_MAP = {
            "さばきのおじかんでしゅ": "katikaku_01_sabaki.mp3",
            "勝利の確率100％": "katikaku_02_syouri.mp3",
            "この展開を待ってたぜー！": "katikaku_03_kono.mp3",
            "リーチかも～": "reach_01_kamo.mp3",
            "なんとかなるなる～": "reach_02_nantoka.mp3",
            "そこでいいのかなー": "reach_03_sokode.mp3",
            "いきますよー！": "reach_04_ikimasu.mp3",
            "疲れてきちゃったなぁ...": "hirou_01_tukare.mp3",
            "ねむい～...": "hirou_02_nemui.mp3",
            "おやつたべたいでしゅ～": "hirou_03_oyatu.mp3"
        };

        // ゲーム終了時の音声リスト
        const WIN_VOICES = ["win_01.mp3", "win_02.mp3", "win_03_jitu.mp3", "win_04_oyasumi.mp3", "win_05_oshimai.mp3", "win_06.mp3", "win_07.mp3", "win_08.mp3", "win_09.mp3", "win_10.mp3", "win_11.mp3"];
        const LOSE_VOICE = ["lose_01.mp3", "lose_02_tekagen.mp3", "lose_03_sontaku.mp3", "lose_04_jinsei.mp3", "lose_05_nipon.mp3", "lose_06_kimiga.mp3", "lose_07_omigoto.mp3", "lose_08.mp3"];
        const TIMEOUT_VOICES = ["timeup_01_oya.mp3", "timeup_02_tekagen.mp3", "timeup_03_jikandesyu.mp3", "timeup_04_jikandesu.mp3"];
        
        // --- NEW: リプレイ時の音声リストを追加 ---
        const REPLAY_VOICES = [
            "replay_01_zeinuki.mp3",
            "replay_02_mou.mp3",
            "replay_03_madamada.mp3",
            "replay_04.mp3",
            "replay_05.mp3"
        ];
        
        // AIの評価値
        const SCORE_WEIGHTS = { 0: 0, 1: 1, 2: 10, 3: 10000, 4: 1000000, 5: 10000000 };
        const IMAGE_BASE_URL = "https://raw.githubusercontent.com/kakinoki-meisaku/gomoku-game/main/assets/images/amemiya_";
        
        // --- NEW: アメミヤチカのピンチ画像URL定義の追加 ---
        const PINCH_01_URL = IMAGE_BASE_URL + "pinch01.png"; // 活四よる勝確時
        const PINCH_02_URL = IMAGE_BASE_URL + "pinch02.png"; // 単一の四連によるリーチ時
        // ------------------------------------
        
        // --- 修正: 石の画像URL定義 ---
        const BLACK_STONE_URL = "https://raw.githubusercontent.com/kakinoki-meisaku/gomoku-game/main/assets/images/kuroishi.png";
        const WHITE_STONE_URL = "https://raw.githubusercontent.com/kakinoki-meisaku/gomoku-game/main/assets/images/shiroishi.png";
        
        // 相手の勝利阻止（即座の5連ブロック）のスコア
        const BLOCK_BONUS = 15000000; 
        // 勝利スコア (最優先: 5連になった場合)
        const WIN_SCORE = SCORE_WEIGHTS[5] * 2; // 20,000,000 
        // 活四 (両辺空き) スコア - 勝利より少し低いが、ブロックより高い
        const OPEN_FOUR_WIN_SCORE = 19000000; // 19,000,000
        
        // --- ランダムメッセージリスト ---
        const RANDOM_MESSAGES = {
            // 活四よる勝確時
            WIN_CONFIRMED: [
                "さばきのおじかんでしゅ",
                "勝利の確率100％",
                "この展開を待ってたぜー！"
            ],
            // 単一の四連によるリーチ時
            REACH: [
                "リーチかも～",
                "なんとかなるなる～",
                "そこでいいのかなー",
                "いきますよー！"
            ],
            // 疲労モード突入時のアナウンス
            FATIGUE_START: [
                "疲れてきちゃったなぁ...",
                "ねむい～...",
                "おやつたべたいでしゅ～"
            ]
        };

        let aiGuaranteedWin = false;
        let isPinchThinking = false; 
        let board = [];
        let currentPlayer = PLAYER_HUMAN;
        let gameActive = true;
        // lastMoveを正確に保持することで、赤い枠の表示を安定させる
        let lastMove = null; 
        let timerInterval = null;
        let timeRemaining = TURN_TIME_LIMIT;
        let moveCount = 0; // 現在盤面にある石の総数
        
        // --- 疲労モード突入時メッセージ表示用フラグ ---
        let hasAnnouncedFatigue = false; 
        // ★★★ 修正ポイント 1: このカウンターを追加 ★★★
        let fatigueVoicePlayedCount = 0; 

        let statusElement;
        let boardElement;
        let timerElement;
        let thinkingIndicator;
        let charImageElement;
        let speechBubbleElement; 
        // --- 修正: モーダル要素からボタンコンテナ要素へ ---
        let resetButtonContainerElement; 
        let modalResetButton; 
        
        // ★★★ NEW: スタート画面関連の要素 ★★★
        let startScreenElement;
        let startButtonElement;
        let gameWrapperElement; // #game-wrapper の要素
        
        // --- NEW: 音声設定関連のグローバル変数 ---
        let bgmVolume = BGM_VOLUME_DEFAULT;
        let seVoiceVolume = 0.8; // デフォルトは0.8

        // --- 雨エフェクト用 グローバル変数 ---
        var W = window.innerWidth; 
        var H = window.innerHeight; 
        let rainCanvas;
        let rainCtx;
        let drops = [];
        let rainAnimationId = null;

        // --- 雨粒の設定 ---
        const DROP_COUNT = 80; 
        const DROP_COLOR = 'rgba(70, 90, 110, 0.85)'; 
        const DROP_LENGTH_MIN = 10;
        const DROP_LENGTH_MAX = 20;
        const DROP_SPEED_MIN = 5;
        const DROP_SPEED_MAX = 12;

        /**
         * 指定されたメッセージタイプからランダムなメッセージを取得
         * @param {string} type - 'WIN_CONFIRMED', 'REACH', 'FATIGUE_START'
         */
        function getRandomMessage(type) {
            const messages = RANDOM_MESSAGES[type];
            if (!messages || messages.length === 0) {
                return `[ERROR: No messages for ${type}]`;
            }
            const randomIndex = Math.floor(Math.random() * messages.length);
            return messages[randomIndex];
        }
        
        // --- 音声設定のロードと保存 ---
        function loadAudioSettings() {
            try {
                const storedBgmVolume = localStorage.getItem('bgmVolume');
                const storedSeVoiceVolume = localStorage.getItem('seVoiceVolume');

                // isMutedのロード処理を削除

                if (storedBgmVolume !== null) {
                    bgmVolume = parseFloat(storedBgmVolume);
                    // BGMオブジェクトが存在すれば音量を適用（isMutedのチェックを削除）
                    if (gameBGM) gameBGM.volume = bgmVolume; 
                } else {
            bgmVolume = BGM_VOLUME_DEFAULT;
                }
                if (storedSeVoiceVolume !== null) {
                    seVoiceVolume = parseFloat(storedSeVoiceVolume);
                } else {
                    seVoiceVolume = 0.8;
                }
            } catch (e) {
                console.warn("Could not load audio settings from localStorage:", e);
                // エラー時はデフォルト値を設定
                bgmVolume = BGM_VOLUME_DEFAULT;
                seVoiceVolume = 0.8;
            }
            // UIに反映
            updateAudioSettingsUI();
        }

        //
        // saveAudioSettings() 関数全体
        function saveAudioSettings() {
            try {
                // isMutedの保存処理を削除
                localStorage.setItem('bgmVolume', bgmVolume);
                localStorage.setItem('seVoiceVolume', seVoiceVolume);
            } catch (e) {
                console.warn("Could not save audio settings to localStorage:", e);
            }
        }
        
        function updateAudioSettingsUI() {
            const bgmSlider = document.getElementById('bgm-volume-slider');
            const seVoiceSlider = document.getElementById('se-voice-volume-slider');
            const icon = document.getElementById('audio-icon');

                if (bgmSlider) bgmSlider.value = bgmVolume * 100;
                if (seVoiceSlider) seVoiceSlider.value = seVoiceVolume * 100;
    
                // muteButtonに関する処理を削除
                
                if (icon) {
                    const imageUrl = 'https://raw.githubusercontent.com/kakinoki-meisaku/gomoku-game/main/assets/images/onpu.png';
                    // スピーカーアイコンの SVG を、指定された音符画像に置き換えます。
                    icon.innerHTML = `<img src="${imageUrl}" alt="音量調整" style="display: block; width: 24px; height: 24px;"/>`;
                }
                            
                // BGMの音量を更新
                if (gameBGM) {
                    // isMutedのチェックを削除
                    gameBGM.volume = bgmVolume; 
                }
            }
        

        function handleBGMVolumeChange(event) {
            const newVolume = event.target.value / 100;
            bgmVolume = newVolume;
        
            if (gameBGM) {
                 // isMutedのチェックを削除
                 gameBGM.volume = bgmVolume;

                 // 【★修正箇所★】
                 if (newVolume > 0 && gameBGM.paused) {
                     // 音量が0より大きくなり、かつBGMが一時停止中の場合、再開する
                     // playBGM()は曲の先頭に戻ってしまうため、play()を直接使用
                     gameBGM.play().catch(e => {
                        console.warn("BGM resume failed:", e.message);
                     });
                 } else if (newVolume === 0 && !gameBGM.paused) {
                     // 音量が0になり、かつBGMが再生中の場合、停止する
                     stopBGM();
                 }
            }

            // isMutedの操作ロジックを削除
            updateAudioSettingsUI();
            saveAudioSettings();
            }

        function handleSEVoiceVolumeChange(event) {
            const newVolume = event.target.value / 100;
            seVoiceVolume = newVolume;
            
            // スライダーが動いた場合のミュート解除ロジックを削除
    
            updateAudioSettingsUI();
            saveAudioSettings();
        }

        // --- 音声再生ロジック ---

        /**
         * 音声をロードし、再生します。
         * @param {string|string[]} fileNames - 再生する音声ファイル名（ランダム再生のために配列も可）
         * @param {number} probability - 再生確率 (0.0から1.0)
         * @returns {boolean} - 音声再生が試みられたかどうか
         */
        function playVoice(fileNames, probability = 1.0) {
            if (seVoiceVolume === 0) return false;
            
            if (Math.random() > probability) {
                return false; 
            }
            
            let fileName = Array.isArray(fileNames) 
                           ? fileNames[Math.floor(Math.random() * fileNames.length)] 
                           : fileNames;
            
            const url = VOICE_BASE_URL + fileName;
            
            // 新しいAudioオブジェクトを作成して再生
            const audioToPlay = new Audio(url);
            // グローバル設定された音量を適用
            audioToPlay.volume = seVoiceVolume; 
            audioToPlay.play().catch(e => {
                // 自動再生ポリシーに引っかかった場合などのエラーを無視
                // console.warn("Audio play failed:", e.message);
            });
            return true;
        }
        
        // ★★★ NEW: 効果音再生関数 (音量調整適用) ★★★
        /**
         * 効果音 (SE) をロードし、再生します。
         * 他の音と重なっても再生されるように、新しいAudioオブジェクトを作成します。
         * @param {string} url - 再生する音声ファイルのURL
         * @param {number} defaultVolume - デフォルトの音量 (0.0から1.0)
         */
        function playSE(url, defaultVolume) {
            if (seVoiceVolume === 0) return;
            
            const audioToPlay = new Audio(url);
            // グローバル設定された音量を適用
            audioToPlay.volume = seVoiceVolume;
            
            audioToPlay.play().catch(e => {
                // 自動再生ポリシーに引っかかった場合などのエラーを無視
                // console.warn("SE play failed:", e.message);
            });
            // 再生終了後、オブジェクトはガベージコレクションに任せる
        }
        // ---------------------------------
        
        // ★★★ NEW: スタート画面の音声再生ロジック ★★★
        function playStartScreenVoice() {
            if (seVoiceVolume === 0) return;
            const chance = 0.8;
            
            // 80%で title_01_ame.mp3 を再生 (START_VOICES[0])
            const played = playVoice(START_VOICES[0], chance);
            
            // 80%の確率で再生されなかった場合 (20%の確率)
            if (!played) {
                // title_02_teru.mp3 を再生 (START_VOICES[1])
                playVoice(START_VOICES[1], 1.0); 
            }
        }
        
        // ★★★ NEW: BGMの再生/再開/リセット関数 (音量調整適用) ★★★
        function playBGM() {
            if (bgmVolume === 0) return;
            
            if (!gameBGM) {
                // BGMオブジェクトが存在しない場合は、ここで初期化
                gameBGM = new Audio(BGM_URL);
                gameBGM.loop = true; // ループ再生を設定
            }
            
            // 再生位置をリセットしてから再生
            gameBGM.currentTime = 0;
            // グローバル設定された音量を適用
            gameBGM.volume = bgmVolume; 
            
            // play()は非同期なので、Promiseのcatchでエラー処理
            gameBGM.play().catch(e => {
                // 自動再生ポリシーなどで再生がブロックされた場合
                console.warn("BGM play blocked, will try again on user interaction:", e.message);
            });
        }
        
        function stopBGM() {
            if (gameBGM) {
                gameBGM.pause();
                // 再生位置はリセットしない（一時停止）
            }
        }

        let originalImageSrc = null; // 元の画像のURLを保持する
        let pinchTimeoutId = null; // 既存のタイマーをクリアするためのID
        
        /**
         * キャラクターの画像を一時的に切り替え、2秒後に元に戻す
         * @param {string} imageUrl - 切り替える新しい画像のURL
         */
        function displayPinchImage(imageUrl) {
            if (!charImageElement) return;
        
            // 既存のタイマーがあればクリアし、前の画像をすぐに元に戻す
            if (pinchTimeoutId) {
                clearTimeout(pinchTimeoutId);
                if (originalImageSrc) {
                    charImageElement.src = originalImageSrc;
                }
            }
        
            // 現在表示されている画像を元の画像として保存
            // 既にピンチ画像が表示されている場合は、元の画像が originalImageSrc に残っているはず
            if (originalImageSrc === null) {
                originalImageSrc = charImageElement.src;
            }
            
            // 新しい画像に切り替える
            charImageElement.src = imageUrl;
        
            // 2秒後に画像を元に戻すタイマーを設定
            pinchTimeoutId = setTimeout(() => {
                if (charImageElement && originalImageSrc) {
                    charImageElement.src = originalImageSrc;
                }
                originalImageSrc = null; // リセット
                pinchTimeoutId = null; // リセット
            }, 2000); // 2秒
        }

        // ★★★ NEW: スタートゲームロジック ★★★
        function startGame() {
            // ★★★ 修正箇所2: スタートボタン押下時の効果音再生を追加 ★★★
            playSE(PIKON_SE_URL, PIKON_SE_VOLUME_DEFAULT); 
            
            // 1. スタートボタン音声再生
            playVoice(START_BUTTON_VOICE, 1.0);
            
            // 2. BGM再生開始
            playBGM();

            // 3. スライドアップアニメーション開始
            // start-screen を画面外（上）に移動させる
            startScreenElement.style.transform = 'translateY(-100vh)';
    
            // 4. アニメーション完了後にゲーム開始 (0.7秒後)
            // gameWrapperElement.classList.add('active-game'); // 不要になったため削除
        
            setTimeout(() => {
                // start-screen をDOMから削除するか、display:noneにする
                startScreenElement.style.display = 'none';
                
                // 5. ゲーム本体の初期化
                initializeGame();
                
                // 6. 音声設定メニューアイコンを表示
                document.getElementById('audio-control-icon').style.display = 'block';
            }, 700); 
        }
        
        // --- NEW: 音声設定メニュー表示/非表示トグル ---
        function toggleAudioSettingsMenu() {
            const menu = document.getElementById('audio-settings-menu');
            if (menu.style.display === 'flex') {
                menu.style.display = 'none';
            } else {
                menu.style.display = 'flex';
                // 表示時に最新のUI設定を反映
                updateAudioSettingsUI();
            }
        }


        /**
         * 指定時間（2秒）後にリセットボタンを表示する
         * NOTE: renderGame() と handleTimeOut() の両方で利用するため関数化
         */
        function showResetButton() {
            if (resetButtonContainerElement) {
                resetButtonContainerElement.style.display = 'block'; 
                resetButtonContainerElement.classList.add('show-reset-button'); 
            }
        }
        
        /**
         * 盤面の初期化とUIのセットアップ
         */
        document.addEventListener('DOMContentLoaded', () => {
            speechBubbleElement = document.getElementById('speech-bubble'); 
            statusElement = document.getElementById('status-text');
            timerElement = document.getElementById('timer');
            thinkingIndicator = document.getElementById('thinking-indicator'); 
            charImageElement = document.getElementById('char-image'); 
            boardElement = document.getElementById('board');
            rainCanvas = document.getElementById('rainCanvas');
            rainCtx = rainCanvas.getContext('2d');
            
            // --- 修正: ボタンコンテナ要素の取得とイベント設定 ---
            resetButtonContainerElement = document.getElementById('reset-button-container'); 
            modalResetButton = document.getElementById('modal-reset-button');
            
            // --- NEW: スタート画面要素の取得とイベント設定 ---
            startScreenElement = document.getElementById('start-screen');
            startButtonElement = document.getElementById('start-button');
            gameWrapperElement = document.getElementById('game-wrapper'); // 新規ラッパー
            const titleImageElement = document.getElementById('title-image');
            
            // --- NEW: 音声設定メニュー要素の取得とイベント設定 ---
            document.getElementById('audio-control-icon').addEventListener('click', toggleAudioSettingsMenu);
            document.getElementById('bgm-volume-slider').addEventListener('input', handleBGMVolumeChange);
            document.getElementById('se-voice-volume-slider').addEventListener('input', handleSEVoiceVolumeChange);
            
            // 起動時に音量設定をロード
            loadAudioSettings();

            startButtonElement.addEventListener('click', startGame);
            titleImageElement.addEventListener('click', playStartScreenVoice);

            window.addEventListener('resize', () => {
                if (rainAnimationId !== null) {
                    initRain();
                }
            });

            initializeBoardUI();
            
            // 💡 修正: initializeGame() の呼び出しを削除し、startGame()に任せる
            // initializeGame(); 
            
            // ボタンにリセット動作を設定
            // ★★★ 修正箇所3: リセットボタン押下時の効果音再生を追加 ★★★
            modalResetButton.addEventListener('click', () => {
                playSE(PIKON_SE_URL, PIKON_SE_VOLUME_DEFAULT); // リセットボタン押下時の効果音
                playBGM(); // リセットボタン押下時はBGMを最初から再生
                initializeGame();
            });
            
        });
        
        // --- 雨エフェクト関連ロジック (変更なし) ---
        class Raindrop {
            constructor() {
                this.reposition();
                this.y = Math.random() * H; 
            }

            reposition() {
                W = window.innerWidth; 
                H = window.innerHeight; 
                this.x = Math.random() * W;
                this.y = -20 - (Math.random() * 300);
                this.length = Math.random() * (DROP_LENGTH_MAX - DROP_LENGTH_MIN) + DROP_LENGTH_MIN;
                this.speed = Math.random() * (DROP_SPEED_MAX - DROP_SPEED_MIN) + DROP_SPEED_MIN;
                this.opacity = Math.random() * 0.5 + 0.2; 
            }

            fall() {
                this.y += this.speed;
                if (this.y > H) {
                    this.reposition();
                }
            }

            draw() {
                rainCtx.beginPath();
                rainCtx.strokeStyle = DROP_COLOR.replace('0.7', this.opacity.toFixed(2));
                rainCtx.lineWidth = 1.5;
                rainCtx.lineCap = 'round';
                rainCtx.moveTo(this.x, this.y);
                rainCtx.lineTo(this.x, this.y + this.length);
                rainCtx.stroke();
            }
        }

        function initRain() {
            W = window.innerWidth;
            H = window.innerHeight;
            rainCanvas.width = W;
            rainCanvas.height = H;
            
            drops = [];
            for (let i = 0; i < DROP_COUNT; i++) {
                drops.push(new Raindrop());
                drops[i].y = Math.random() * H; 
            }
        }

        function animateRain() {
            rainCtx.clearRect(0, 0, W, H);
            
            for (let i = 0; i < drops.length; i++) {
                drops[i].fall();
                drops[i].draw();
            }
            
            if (rainAnimationId !== null) {
                rainAnimationId = requestAnimationFrame(animateRain);
            }
        }

        function startRain() {
            if (rainAnimationId === null) {
                initRain(); 
                rainCanvas.style.display = 'block';
                rainAnimationId = requestAnimationFrame(animateRain);
            }
        }

        function stopRain() {
            if (rainAnimationId !== null) {
                cancelAnimationFrame(rainAnimationId);
                rainAnimationId = null;
                rainCanvas.style.display = 'none';
            }
        }

/**
         * 勝利時に、現在のターン数に応じて報酬画像を表示する
         */
        function displayWinImage() {
            if (!resetButtonContainerElement) return; // コンテナ要素がなければ何もしない

            // 疲労モード判定: moveCount が FATIGUE_THRESHOLD 以上か
            const isFatigueWin = moveCount >= FATIGUE_THRESHOLD;
            const imageUrl = isFatigueWin ? GOHOUBI_B_URL : GOHOUBI_A_URL;
            const altText = isFatigueWin ? "疲労モード時のごほうび画像" : "通常時のごほうび画像";

            // 既存の画像を削除してから追加 (リセット/再戦時のために)
            const existingImage = document.getElementById('gohoubi-image');
            if (existingImage) {
                existingImage.remove();
            }

            const imageElement = document.createElement('img');
            imageElement.id = 'gohoubi-image';
            imageElement.src = imageUrl;
            imageElement.alt = altText;
            // Tailwind CSS クラスでスタイリング: 幅100%、最大幅250px、中央寄せ、下マージン
            imageElement.classList.add('w-full', 'max-w-xs', 'mx-auto', 'mb-4'); 
            imageElement.style.maxWidth = '250px'; 

            // 「もう一回」ボタンの要素を取得
            const resetButton = document.getElementById('modal-reset-button');

            if (resetButton) {
                // ボタンの直前に画像を挿入
                resetButtonContainerElement.insertBefore(imageElement, resetButton);
            } else {
                // ボタンが見つからなければコンテナの末尾に追加
                resetButtonContainerElement.appendChild(imageElement);
            }
        }
 
 
        // --- ゲーム本体ロジック ---
        
        /**
         * ゲーム状態を初期化
         */
        function initializeGame() {
            // ★★★ NEW: リプレイ音声の再生を追加 ★★★
            // ただし、初回ロード時や、ゲームオーバー後にしかボタンが表示されないことを考慮し、
            // 盤面に石が一つも置かれていない状態（moveCount === 0）でなければ再生する。
            // (初回ロード時、またはリセットボタンを押さずに開発者が直接initializeGameを呼んだ場合、moveCountは0のまま)
            if (moveCount > 0) { 
                playVoice(REPLAY_VOICES, 1.0); // 100%の確率でランダム再生
            }            
            
            // --- NEW: 勝利時画像をクリア ---
            const existingImage = document.getElementById('gohoubi-image');
            if (existingImage) {
                existingImage.remove();
            }
            // --------------------------------
            
            board = Array(BOARD_SIZE).fill(0).map(() => Array(BOARD_SIZE).fill(0));
            currentPlayer = PLAYER_HUMAN;
            gameActive = true;
            lastMove = null;
            moveCount = 0;
            hasAnnouncedFatigue = false; 
            // ★★★ 修正ポイント 2: カウンターをリセット ★★★
            fatigueVoicePlayedCount = 0; 
            
            clearInterval(timerInterval);
            timeRemaining = TURN_TIME_LIMIT;
            
            if (timerElement) {
                timerElement.innerHTML = `持ち時間: <span class="text-lg font-extrabold">${TURN_TIME_LIMIT}</span> 秒`;
            }
            
            if (thinkingIndicator) thinkingIndicator.textContent = ""; 
            
            stopRain(); 
            setCharacterMood('normal', 'normal'); // ★修正: moodTypeを渡すように変更
            updateStatus(`対局開始！あなた（黒）のターンです。`, 'normal'); // updateStatusを呼び出し
            
            // --- NEW: 音声設定メニューを非表示に ---
            const audioSettingsMenu = document.getElementById('audio-settings-menu');
            if (audioSettingsMenu) audioSettingsMenu.style.display = 'none';


            // --- 修正: ボタンコンテナを非表示に戻す ---
            if (resetButtonContainerElement) {
                resetButtonContainerElement.classList.remove('show-reset-button'); 
                // アニメーションのために遅延させてからdisplay: none
                setTimeout(() => { resetButtonContainerElement.style.display = 'none'; }, 300); 
            }
            
        // ★★★ NEW: ゲームUIを表示させる ★★★
        // if (gameWrapperElement) {
        //     gameWrapperElement.style.visibility = 'visible';
        // }
            
            renderGame();
        }
        
        /**
         * キャラクターの表情を切り替える関数
         * @param {string} mood - 'normal', 'win', 'loss', 'thinking', 'smile', 'reach', 'tired'
         * @param {string} moodType - 'normal', 'win_confirmed', 'reach', 'tired' などの現在のゲーム状況を示すタイプ
         */
        function setCharacterMood(mood, moodType = 'normal') {
            if (!charImageElement) return;

            let suffix = 'normal.png'; 

            if (mood === 'win') {
                suffix = 'win.png'; 
            } else if (mood === 'loss') {
                suffix = 'lose.png'; 
            } else if (mood === 'thinking') {
                suffix = 'think.png'; 
            } else if (mood === 'smile') {
                suffix = 'smile.png'; 
            } else if (mood === 'reach') {
                // ★★★ 修正ポイント: リーチのタイプによって画像を切り替える ★★★
                if (moodType === 'win_confirmed') {
                    // 勝確につながるリーチ (活四など)
                    suffix = 'reach01.png'; 
                } else if (moodType === 'reach') {
                    // 単なるリーチ (四連など)
                    suffix = 'reach02.png'; // 新しい画像
                } else {
                    suffix = 'reach01.png'; // デフォルトはreach01
                }
            } else if (mood === 'tired') { 
                suffix = 'tired.png'; 
            }
            
            const path = IMAGE_BASE_URL + suffix;
            
            charImageElement.onerror = () => {
                charImageElement.src = 'https://placehold.co/160x160/cccccc/333333?text=Char';
            };
            
            charImageElement.src = path;
        }
        
        // ----------------------------------------------------
        // ★★★ NEW: プレイヤーの脅威度をチェックする関数を追加 ★★★
        // ----------------------------------------------------
        
        /**
         * プレイヤー (黒) の着手によって生じた脅威度をチェックする。
         * (活四、または単一の四連を検出)
         * @param {number} r - 着手した行
         * @param {number} c - 着手した列
         * @returns {'WIN_CONFIRMED'|'REACH'|'NONE'} - 活四、四連リーチ、または脅威なし
         */
        function checkHumanThreats(r, c) {
            const player = PLAYER_HUMAN;
            const directions = [
                [0, 1],  // 水平
                [1, 0],  // 垂直
                [1, 1],  // 右下がり斜め
                [1, -1]  // 左下がり斜め
            ];
        
            let hasLiveFour = false; // 活四（両端空き）
            let hasFourInARow = false; // 単一の四連（片端または両端空き）
        
            for (const [dr, dc] of directions) {
                let count = 1;
                let openEnds = 0; 
                
                // 1. 正の方向
                for (let i = 1; i <= 4; i++) {
                    const nr = r + dr * i;
                    const nc = c + dc * i;
                    if (nr >= 0 && nr < BOARD_SIZE && nc >= 0 && nc < BOARD_SIZE && board[nr][nc] === player) {
                        count++;
                    } else {
                        if (nr >= 0 && nr < BOARD_SIZE && nc >= 0 && nc < BOARD_SIZE && board[nr][nc] === 0) {
                            openEnds++;
                        }
                        break;
                    }
                }
                
                // 2. 負の方向
                for (let i = 1; i <= 4; i++) {
                    const nr = r - dr * i;
                    const nc = c - dc * i;
                    if (nr >= 0 && nr < BOARD_SIZE && nc >= 0 && nc < BOARD_SIZE && board[nr][nc] === player) {
                        count++;
                    } else {
                        if (nr >= 0 && nr < BOARD_SIZE && nc >= 0 && nc < BOARD_SIZE && board[nr][nc] === 0) {
                            openEnds++;
                        }
                        break;
                    }
                }
                
                if (count === 4) {
                    // 四連が成立
                    if (openEnds === 2) {
                        hasLiveFour = true; // 活四（勝確）
                    }
                    if (openEnds >= 1) {
                        hasFourInARow = true; // リーチ（片端または両端空き）
                    }
                }
            }
        
            if (hasLiveFour) {
                return 'WIN_CONFIRMED';
            } else if (hasFourInARow) {
                return 'REACH';
            }
            
            return 'NONE';
        }
        
        
        function initializeBoardUI() {
            if (!boardElement) return;
            boardElement.innerHTML = '';
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    const cell = document.createElement('div');
                    cell.classList.add('cell');
                    cell.dataset.row = r;
                    cell.dataset.col = c;
                    
                    // 盤面の交点にセルを配置
                    const interval = 100 / (BOARD_SIZE - 1);
                    const leftPos = c * interval; 
                    const topPos = r * interval;
                    
                    cell.style.left = `${leftPos}%`;
                    cell.style.top = `${topPos}%`;
                    cell.style.transform = 'translate(-50%, -50%)'; 
                    
                    cell.addEventListener('click', () => handleCellClick(r, c));
                    boardElement.appendChild(cell);
                }
            }
        }
        
        function renderGame() {
            if (!boardElement || !timerElement || !thinkingIndicator) return;

            const cells = boardElement.querySelectorAll('.cell');
            cells.forEach(cell => {
                const r = parseInt(cell.dataset.row);
                const c = parseInt(cell.dataset.col);
                const player = board[r][c];

                cell.innerHTML = ''; 
                
                if (player !== 0) {
                    const piece = document.createElement('div');
                    piece.classList.add('piece');
                    
                    // --- 修正: 画像を適用 ---
                    if (player === PLAYER_HUMAN) {
                        piece.style.backgroundImage = `url('${BLACK_STONE_URL}')`;
                    } else {
                        piece.style.backgroundImage = `url('${WHITE_STONE_URL}')`;
                    }
                    piece.style.backgroundColor = 'transparent'; // 背景色は透明に
                    
                    // 💡 修正: ここでpieceを追加
                    cell.appendChild(piece);
                    
                    // --- 💡 新規追加: 最後に置いた石の上にハイライトを重ねる ---
                    if (lastMove && lastMove.r === r && lastMove.c === c) {
                        const highlight = document.createElement('div');
                        highlight.classList.add('last-move-highlight');
                        // piece(z:20)よりも上に配置される(z:30)
                        cell.appendChild(highlight); 
                    }
                    // ----------------------------------------------------
                }
            });

            if (!gameActive) { // ★修正: ゲーム終了判定を統合
                // 勝利線ハイライト
                if (lastMove) {
                    const winningCoords = findWinningLine(lastMove.r, lastMove.c, lastMove.player);
                    if (winningCoords) {
                        highlightWinningLine(winningCoords);
                    }
                }
                
            } else if (gameActive) {
                // ゲーム中はボタンコンテナを非表示
                if (resetButtonContainerElement) {
                    resetButtonContainerElement.classList.remove('show-reset-button'); 
                    // アニメーションのために遅延させてからdisplay: none
                    setTimeout(() => { resetButtonContainerElement.style.display = 'none'; }, 300); 
                }

                clearInterval(timerInterval);
                if (currentPlayer === PLAYER_HUMAN) {
                    // 人間のターンでは思考中インジケータを非表示
                    thinkingIndicator.textContent = ""; 
                    thinkingIndicator.style.display = 'none'; 
                    timerElement.style.display = 'block';
                    if (moveCount > 0) { 
                        startTimer();
                    } else {
                        timerElement.innerHTML = "最初の1手は時間無制限です";
                    }
                } else {
                    // 修正: AIターン時はタイマーを非表示にし、思考中インジケータを表示
                    timerElement.style.display = 'none'; 
                    thinkingIndicator.style.display = 'block'; 
                    // AIの思考開始
                    setTimeout(() => { if (gameActive) aiTurn(); }, 500); 
                }
            }
        }

        function highlightWinningLine(coords) {
            coords.forEach(([r, c]) => {
                const cell = document.querySelector(`.cell[data-row="${r}"][data-col="${c}"]`);
                if (cell) {
                    cell.querySelector('.piece')?.classList.add('winning-piece');
                }
            });
        }

        function findWinningLine(r, c, player) {
            const directions = [
                [0, 1], [1, 0], [1, 1], [1, -1]
            ];
            
            for (const [dr, dc] of directions) {
                let line = [];
                let maxCount = 0;
                let winningStones = [];

                for (let i = -4; i <= 4; i++) {
                    const nr = r + i * dr;
                    const nc = c + i * dc;

                    if (nr >= 0 && nr < BOARD_SIZE && nc >= 0 && nc < BOARD_SIZE) {
                        if (board[nr][nc] === player) {
                            line.push([nr, nc]);
                        } else {
                            if (line.length > maxCount) {
                                maxCount = line.length;
                                winningStones = [...line];
                            }
                            line = [];
                        }
                    } else {
                         if (line.length > maxCount) {
                            maxCount = line.length;
                            winningStones = [...line];
                        }
                        line = [];
                    }
                }
                if (line.length > maxCount) {
                    maxCount = line.length;
                    winningStones = [...line];
                }

                if (maxCount >= 5) {
                    return winningStones.slice(0, 5);
                }
            }
            return null;
        }

        
        function startTimer() {
            if (!timerElement || !speechBubbleElement) return;

            timeRemaining = TURN_TIME_LIMIT;
            
            const statusDiv = speechBubbleElement;
            statusDiv.classList.remove('bg-red-400', 'bg-red-500', 'bg-red-600', 'shadow-red-400/80', 'shadow-red-500/80', 'shadow-red-600/80', 'animate-pulse');
            statusDiv.classList.add('bg-blue-500', 'shadow-blue-500/80'); 

            // 人間のターンではタイマーを表示
            timerElement.innerHTML = `残り時間: <span class="text-lg font-extrabold">${timeRemaining}</span> 秒`;
            // renderGameで表示制御しているのでここでは不要
            // timerElement.style.display = 'block'; 

            timerInterval = setInterval(() => {
                timeRemaining--;
                
                timerElement.innerHTML = `残り時間: <span class="text-lg font-extrabold">${timeRemaining}</span> 秒`;

                statusDiv.classList.remove('bg-red-400', 'bg-red-500', 'bg-red-600', 'shadow-red-400/80', 'shadow-red-500/80', 'shadow-red-600/80', 'animate-pulse');
                statusDiv.classList.remove('bg-blue-500', 'shadow-blue-500/80'); 

                if (timeRemaining <= 0) {
                    clearInterval(timerInterval);
                    handleTimeOut();
                } else if (timeRemaining <= 3) {
                    if (timeRemaining === 3) {
                        statusDiv.classList.add('bg-red-400', 'shadow-red-400/80');
                    } else if (timeRemaining === 2) {
                        statusDiv.classList.add('bg-red-500', 'shadow-red-500/80');
                    } else if (timeRemaining === 1) {
                        statusDiv.classList.add('bg-red-600', 'shadow-red-600/80', 'animate-pulse');
                    }
                } else {
                     statusDiv.classList.add('bg-blue-500', 'shadow-blue-500/80'); 
                }
            }, 1000);
        }

        function handleTimeOut() {
            gameActive = false;
            clearInterval(timerInterval); // ★修正: 時間切れなのでタイマーも停止
            stopRain();
            // ★★★ 修正: ゲーム終了時にBGMを停止 ★★★
            stopBGM(); 
            if (thinkingIndicator) thinkingIndicator.textContent = ""; 
            updateStatus(`【時間切れ】10秒以内に石を置けませんでした。${AI_NAME}の勝ちです！`, 'loss'); 
            
            // 💡 追加: 時間切れのランダム音声再生
            playVoice(TIMEOUT_VOICES); 

            renderGame(); 
            
            // --- NEW: 2秒後にリセットボタンを表示 ---
            setTimeout(showResetButton, 2000); 
        }

        function handleCellClick(r, c) {
            if (!gameActive || currentPlayer !== PLAYER_HUMAN) return;
            if (board[r][c] !== 0) return;
            
            if (thinkingIndicator) thinkingIndicator.textContent = "";

            clearInterval(timerInterval);
            placePiece(r, c, PLAYER_HUMAN, null); 
        }

        async function placePiece(r, c, player, threatType = null) {
            if (board[r][c] !== 0) {
                console.error(`Error: Tried to place piece at occupied cell (${r}, c).`);
                gameActive = false;
                updateStatus(`【エラー】無効な場所への着手が発生しました。ゲームをリセットしてください。`, 'draw');
                // --- NEW: 2秒後にリセットボタンを表示 ---
                setTimeout(showResetButton, 2000); 
                return;
            }
            
            // プレイヤー（黒）が石を置いた場合のみ、脅威レベルをチェックしSEを分岐
            if (player === PLAYER_HUMAN) {
                // プレイヤー（黒）の着手時

                // 1. 石を置く前に、一旦空きマスとして処理
                // 2. checkThreateningLine(r, c, player) を呼び出すと、
                //    内部で board[r][c] = player; -> 判定 -> board[r][c] = 0; が行われる。
                let isCritical = checkThreateningLine(r, c, player);

                // 3. checkThreateningLine が石を元に戻してしまうため、ここで石を置き直す。
                board[r][c] = player; 

                // 4. 活四による即座の勝利もリーチと見なす
                if (isCritical || checkWin(r, c, player)) {
                    playSE(CRITICAL_SE_URL, PIECE_PUT_SE_VOLUME_DEFAULT);
                } else {
                    playSE(PIECE_PUT_SE_URL, PIECE_PUT_SE_VOLUME_DEFAULT);
                }
            } else {
                // AI（白）の着手時
                playSE(PIECE_PUT_SE_URL, PIECE_PUT_SE_VOLUME_DEFAULT);
                board[r][c] = player; // AIの着手はここで確定
            }
            // ------------------------------------
            lastMove = { r, c, player };
            
            moveCount++; 
            
            if (thinkingIndicator) thinkingIndicator.textContent = ""; 

            if (checkWin(r, c, player)) {
                gameActive = false;
                stopRain(); 
                // ★★★ 修正: ゲーム終了時にBGMを停止 ★★★
                stopBGM(); 
                const winnerText = player === PLAYER_HUMAN ? `あなた` : `${AI_NAME}`; 
                const statusType = player === PLAYER_HUMAN ? 'win' : 'loss';
                updateStatus(`${winnerText}の勝ちです！`, statusType);
                
                // 💡 追加: 勝利者に応じた音声再生
                if (player === PLAYER_AI) {
                    playVoice(WIN_VOICES); // AIが勝った時
                } else {
                    playVoice(LOSE_VOICE); // プレイヤーが勝った時
                    displayWinImage();
                }

                renderGame(); 
                // --- NEW: 2秒後にリセットボタンを表示 ---
                setTimeout(() => { //
                    renderGame(); // 勝利線ハイライトのためにレンダリング //
                    showResetButton(); //
                }, 2000);

            } else if (isDraw()) {
                gameActive = false;
                stopRain(); 
                // ★★★ 修正: ゲーム終了時にBGMを停止 ★★★
                stopBGM(); 
                updateStatus(`【引き分け】碁盤がすべて埋まりました。`, 'draw');
                renderGame(); 
                // --- NEW: 2秒後にリセットボタンを表示 ---
                setTimeout(showResetButton, 2000); 
            } else {
                await switchTurn(threatType);
            }
        }

        async function switchTurn(threatType = null) {
            currentPlayer = currentPlayer === PLAYER_HUMAN ? PLAYER_AI : PLAYER_HUMAN;
            renderGame();
            
            const turnText = currentPlayer === PLAYER_HUMAN ? `あなた（黒）` : `${AI_NAME}（白）`; 
            
            let message = `${turnText}のターンです。`;
            
            // 修正: moveCount > FATIGUE_THRESHOLD に修正（石が25個以上なら疲労モード）
            const isFatigued = moveCount >= FATIGUE_THRESHOLD; 
            let statusType = isFatigued ? 'tired' : 'normal'; // デフォルトのステータスタイプ

            if (gameActive) {
                if (isFatigued) {
                    startRain(); 
                    
                    // ↓↓↓ 修正が必要なブロック: hasAnnouncedFatigueのチェックとカウンターの利用 ↓↓↓
                    if (!hasAnnouncedFatigue && fatigueVoicePlayedCount === 0) { // ★修正点1: カウンターもチェック
                        setCharacterMood('tired', 'tired'); // ★修正: moodTypeを渡すように変更
                        const fatigueMsg = getRandomMessage('FATIGUE_START');
                        message = fatigueMsg;
                        statusType = 'tired';
                        
                        // 💡 追加: 疲労モード突入時メッセージと対応する音声再生
                        playVoice(MESSAGE_VOICE_MAP[fatigueMsg], 1.0); 

                        // ★★★ 修正ポイント 3: 再生したのでカウンターを1に設定 ★★★
                        fatigueVoicePlayedCount = 1; // ★修正点2: カウンターをインクリメント

                        await new Promise(resolve => setTimeout(resolve, 1500));
                        hasAnnouncedFatigue = true;
                        
                        // アナウンス後、改めてターンメッセージに戻る
                        message = `${turnText}のターンです。`;
                        
                        // 確定メッセージを反映（メッセージ・表情は維持）
                        updateStatus(message, 'tired'); 
            
                        // ★修正点3: このreturnは削除しない
                        return;
                    } else if (hasAnnouncedFatigue) { // ★修正点4: 既にアナウンス済みで、疲労モードに入っている場合
                    
                        // リーチ/勝確の脅威が直前に発生した場合、AIターンに移る前に'reach'を優先
                        if (threatType === 'reach' || threatType === 'win_confirmed') {
                             // statusType はそのまま threatType に上書き
                             statusType = threatType;
                             // setCharacterMood の呼び出しは updateStatus に任せる
                        } else {
                            // 疲労モード中、脅威がない場合は 'tired' に固定
                            // setCharacterMood の呼び出しは updateStatus に任せる
                        }
                    }
                    // ↑↑↑ 修正が必要なブロック ここまで ↑↑↑
                    
                } else {
                    // 非疲労モードでも、直前に脅威があった場合は表情を維持
                    if (threatType === 'reach' || threatType === 'win_confirmed') {
                        statusType = threatType;
                        // setCharacterMood の呼び出しは updateStatus に任せる
                    }
                }
            } else {
                // ゲーム終了時は何もしない
            }
            
            // ★ 修正: メッセージ更新を確実にするため、updateStatusを呼び出す
            updateStatus(message, statusType);


            // thinkingIndicator の表示制御は renderGame に任せる
            // statusElement.style.display は updateStatus に任せる
        }
        
        /**
         * ステータス表示の更新
         * @param {string} message - 表示するメッセージ
         * @param {string} type - 'normal', 'win', 'loss', 'draw', 'win_confirmed', 'reach', 'tired'
         */
        function updateStatus(message, type = 'normal') {
            if (!statusElement || !speechBubbleElement) return; 
            
            statusElement.textContent = message;
            
            const statusDiv = speechBubbleElement;
            statusDiv.className = 'absolute z-20 md:w-80 w-[90%] p-3 rounded-xl shadow-2xl transition-colors duration-300 left-1/2 -translate-x-1/2 bottom-2 text-white';
            
            statusDiv.classList.add('p-3');
            statusElement.style.display = 'block';

            // ★ 修正: タイプに応じて表情と色を更新 ★
            if (type === 'win') { 
                statusDiv.classList.add('bg-green-500', 'shadow-green-500/80'); 
                setCharacterMood('loss', type); // 相手（AI）の敗北表情
            } else if (type === 'loss') { 
                statusDiv.classList.add('bg-red-500', 'shadow-red-500/80');
                setCharacterMood('win', type); // 相手（AI）の勝利表情
                stopRain(); 
            } else if (type === 'draw') {
                statusDiv.classList.remove('text-white');
                statusDiv.classList.add('bg-yellow-400', 'text-gray-800', 'shadow-yellow-400/80');
                setCharacterMood('normal', type);
                stopRain(); 
            } else if (type === 'win_confirmed') { 
                statusDiv.classList.add('bg-red-700', 'shadow-red-700/80');
                setCharacterMood('reach', type); // ★修正: win_confirmedの表情（reach01）
            } else if (type === 'reach') {
                statusDiv.classList.add('bg-pink-600', 'shadow-pink-600/80');
                setCharacterMood('reach', type); // ★修正: reachの表情（reach02）
            } else if (type === 'tired') {
                 statusDiv.classList.add('bg-gray-700', 'shadow-gray-700/80');
                 setCharacterMood('tired', type);
            } else {
                // normal
                statusDiv.classList.add('bg-blue-500', 'shadow-blue-500/80');
                setCharacterMood('normal', type);
            }
        }
        

        function checkWin(r, c, player) {
            return findWinningLine(r, c, player) !== null;
        }

        function countConsecutive(r, c, dr, dc, player) {
            let count = 0;
            let openEnds = 0;
            let blocked = 0;
            const opponent = 3 - player;

            let currentR = r + dr;
            let currentC = c + dc;
            while (currentR >= 0 && currentR < BOARD_SIZE && currentC >= 0 && currentC < BOARD_SIZE && board[currentR][currentC] === player) {
                count++;
                currentR += dr;
                currentC += dc;
            }

            if (currentR >= 0 && currentR < BOARD_SIZE && currentC >= 0 && currentC < BOARD_SIZE && board[currentR][currentC] === 0) {
                openEnds++;
            } else if (currentR < 0 || currentR >= BOARD_SIZE || currentC < 0 || currentC >= BOARD_SIZE || board[currentR][currentC] === opponent) {
                blocked++;
            }

            currentR = r - dr;
            currentC = c - dc;
            while (currentR >= 0 && currentR < BOARD_SIZE && currentC >= 0 && currentC < BOARD_SIZE && board[currentR][currentC] === player) {
                count++;
                currentR -= dr;
                currentC -= dc;
            }

            if (currentR >= 0 && currentR < BOARD_SIZE && currentC >= 0 && currentC < BOARD_SIZE && board[currentR][currentC] === 0) {
                openEnds++;
            } else if (currentR < 0 || currentR >= BOARD_SIZE || currentC < 0 || currentC >= BOARD_SIZE || board[currentR][currentC] === opponent) {
                blocked++;
            }
            
            return { count: count + 1, openEnds, blocked: blocked > 0 };
        }

        function getLineScore(r, c, dr, dc, player) {
            const result = countConsecutive(r, c, dr, dc, player);
            
            if (result.count >= 5) {
                return WIN_SCORE;
            }
            
            if (result.count === 4) {
                if (result.openEnds === 2) {
                    return OPEN_FOUR_WIN_SCORE; 
                }
                if (result.openEnds >= 1) {
                    return SCORE_WEIGHTS[4]; 
                }
            }
            
            if (result.count === 3) {
                if (result.openEnds === 2) {
                    return SCORE_WEIGHTS[3]; 
                }
                if (result.openEnds === 1) {
                    return SCORE_WEIGHTS[2]; 
                }
            }

            if (result.count === 2 && result.openEnds === 2) {
                return SCORE_WEIGHTS[1];
            }
            
            if (result.blocked || result.openEnds === 0) {
                return 0;
            }

            return 0;
        }
        
        function checkOpenFour(r, c, player) {
            board[r][c] = player; 
            
            const directions = [
                [0, 1], [1, 0], [1, 1], [1, -1]
            ];
            
            for (const [dr, dc] of directions) {
                const result = countConsecutive(r, c, dr, dc, player);
                
                if (result.count === 4 && result.openEnds === 2) {
                    board[r][c] = 0; 
                    return true;
                }
            }
            
            board[r][c] = 0; 
            return false;
        }
        
        
        // 盤面全体をスキャンし、特定のプレイヤーの活四があるかを確認する
        function checkThreatsAcrossBoard(player) {
            const opponent = 3 - player;
            // 盤面全体をスキャン
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    // プレイヤーの石が置かれていないマス（空きマス）が対象
                    if (board[r][c] === 0) {
                        // そのマスにプレイヤーの石を仮置きしてみる
                        board[r][c] = player;
                        
                        // 活四 (WIN_CONFIRMED) が成立するかチェック
                        if (checkOpenFour(r, c, player)) {
                            board[r][c] = 0; // 仮置きした石を元に戻す
                            return 'WIN_CONFIRMED';
                        }
                        
                        board[r][c] = 0; // 仮置きした石を元に戻す
                    }
                }
            }
            return 'NONE'; // 活四は見つからなかった
        }
        
        
        function checkDoubleOpenThree(r, c, player) {
            board[r][c] = player; 
            
            const directions = [
                [0, 1], [1, 0], [1, 1], [1, -1]
            ];
            let openThreeCount = 0;
            
            for (const [dr, dc] of directions) {
                const result = countConsecutive(r, c, dr, dc, player);
                
                if (result.count === 3 && result.openEnds === 2) {
                    openThreeCount++;
                }
            }
            
            board[r][c] = 0; 

            return openThreeCount >= 2;
        }


        function checkThreateningLine(r, c, player) {
            board[r][c] = player; 
            const directions = [ [0, 1], [1, 0], [1, 1], [1, -1] ];
            const opponent = 3 - player;

            for (const [dr, dc] of directions) {
                for (let i = -4; i <= 0; i++) {
                    let p_count = 0;      
                    let empty_count = 0;  
                    let opponent_found = false; 

                    for (let j = 0; j < 5; j++) {
                        const cr = r + (i + j) * dr;
                        const cc = c + (i + j) * dc;

                        if (cr < 0 || cr >= BOARD_SIZE || cc < 0 || cc >= BOARD_SIZE) {
                            opponent_found = true;
                            break;
                        }
                        
                        const piece = board[cr][cc];
                        if (piece === player) {
                            p_count++;
                        } else if (piece === 0) {
                            empty_count++;
                        } else if (piece === opponent) {
                            opponent_found = true;
                            break; 
                        }
                    }

                    if (p_count === 4 && empty_count === 1 && !opponent_found) {
                        board[r][c] = 0; 
                        return true;
                    }
                }
            }

            board[r][c] = 0; 
            return false;
        }
        
        function getAvailableMoves() {
            const moves = [];
            const checkRange = 3; 
            
            const occupied = [];
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    if (board[r][c] !== 0) {
                        occupied.push({ r, c });
                    }
                }
            }

            const candidateCoords = new Set();
            
            if (occupied.length === 0) {
                const centerR = Math.floor(BOARD_SIZE / 2);
                const centerC = Math.floor(BOARD_SIZE / 2);
                for (let r = centerR - 1; r <= centerR + 1; r++) {
                    for (let c = centerC - 1; c <= centerC + 1; c++) {
                        if (r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE) {
                            moves.push({r, c});
                        }
                    }
                }
                return moves.length > 0 ? moves : [{r: centerR, c: centerC}];
            } else {
                occupied.forEach(({ r, c }) => {
                    for (let dr = -checkRange; dr <= checkRange; dr++) {
                        for (let dc = -checkRange; dc <= checkRange; dc++) {
                            const newR = r + dr;
                            const newC = c + dc;
                            
                            if (newR >= 0 && newR < BOARD_SIZE && newC >= 0 && newC < BOARD_SIZE && board[newR][newC] === 0) {
                                candidateCoords.add(`${newR},${newC}`);
                            }
                        }
                    }
                });
            }

            candidateCoords.forEach(coordStr => {
                const [r, c] = coordStr.split(',').map(Number);
                moves.push({ r, c });
            });

            if (moves.length === 0 && moveCount < BOARD_SIZE * BOARD_SIZE) {
                for (let r = 0; r < BOARD_SIZE; r++) {
                    for (let c = 0; c < BOARD_SIZE; c++) {
                        if (board[r][c] === 0) {
                            moves.push({ r, c });
                            return moves; 
                        }
                    }
                }
            }

            return moves;
        }
        
        function findBestMove(player) {
            const opponent = 3 - player;
            const availableMoves = getAvailableMoves();
            const scoredMoves = [];

            if (availableMoves.length === 0) {
                return [];
            }
            
            const directions = [
                [0, 1], [1, 0], [1, 1], [1, -1] 
            ];

            for (const move of availableMoves) {
                const { r, c } = move;
                let score = 0;
                
                board[r][c] = player;
                if (checkWin(r, c, player)) {
                    board[r][c] = 0;
                    return [{ move: {r, c}, score: WIN_SCORE }]; 
                }
                board[r][c] = 0; 

                board[r][c] = opponent; 
                if (checkWin(r, c, opponent)) {
                    board[r][c] = 0; 
                    score += BLOCK_BONUS; 
                }
                board[r][c] = 0; 
                
                board[r][c] = player; 
                let defenseScore = 0;
                board[r][c] = opponent; 
                for (const [dr, dc] of directions) {
                    const opponentLineScore = getLineScore(r, c, dr, dc, opponent);
                    defenseScore = Math.max(defenseScore, opponentLineScore);
                }
                board[r][c] = 0;
                
                score += defenseScore * 2; 
                
                board[r][c] = player;
                let selfScore = 0;
                for (const [dr, dc] of directions) {
                    selfScore += getLineScore(r, c, dr, dc, player);
                }
                
                board[r][c] = 0;
                
                score += selfScore;

                const center = Math.floor(BOARD_SIZE / 2);
                const distance = Math.max(Math.abs(r - center), Math.abs(c - center));
                score += (BOARD_SIZE - distance) * 5; 

                scoredMoves.push({ move: { r, c }, score });
            }

            scoredMoves.sort((a, b) => b.score - a.score);

            return scoredMoves;
        }

        async function aiTurn() { 
            if (!gameActive) { if (thinkingIndicator) thinkingIndicator.textContent = ""; return; } 

            if (thinkingIndicator) thinkingIndicator.textContent = "思考中..."; 
            
            // 疲労モードかどうかに関わらず、思考中は 'thinking' にする
			// isPinchThinkingがtrueの場合は、thinking顔への切り替えをスキップする
            if (!isPinchThinking) { 
                setCharacterMood('thinking', 'thinking'); // moodTypeを渡すように変更
            }

            await new Promise(resolve => setTimeout(resolve, 800 + Math.random() * 500)); 
            
            // AIが思考を終えたら、ピンチ思考フラグをリセット
            isPinchThinking = false;
            
            if (!gameActive) { if (thinkingIndicator) thinkingIndicator.textContent = ""; return; } 

            const scoredMoves = findBestMove(PLAYER_AI);
            
            if (scoredMoves.length === 0) {
                 if (thinkingIndicator) thinkingIndicator.textContent = "";
                 await switchTurn(null);
                 return;
            }

            let bestMove = scoredMoves[0]?.move;
            const topScore = scoredMoves[0]?.score || 0; 
            
            const isImmediateWin = topScore === WIN_SCORE; 
            
            const moveNumberToPlay = moveCount + 1; 
            const isFatigued = moveNumberToPlay >= FATIGUE_THRESHOLD;
            
            // ★ 修正1: 次のターンで疲労アナウンスが発生するかどうかをチェック ★
            // hasAnnouncedFatigueがfalseであれば、次のターン（プレイヤーのターン）で疲労ボイスが再生される
            // ※ fatigueVoicePlayedCount === 0 の方が、音声が再生されるかどうかをより確実に示します。
            const willAnnounceFatigueNextTurn = isFatigued && !hasAnnouncedFatigue && fatigueVoicePlayedCount === 0; // ★修正点1: カウンターチェックを追加
            
            let finalMove = bestMove;
            
            if (isFatigued && !isImmediateWin && scoredMoves.length > 1) { 
                if (Math.random() < FATIGUE_ERROR_CHANCE) { 
                    finalMove = scoredMoves[1].move; 
                    console.log(`AI Fatigue: Chose 2nd best move. Error Chance: ${FATIGUE_ERROR_CHANCE}`);
                }
            }

            board[finalMove.r][finalMove.c] = PLAYER_AI; 
            const isFinalMoveImmediateWin = checkWin(finalMove.r, finalMove.c, PLAYER_AI);
            board[finalMove.r][finalMove.c] = 0; 

            
            const isFinalMoveOpenFour = checkOpenFour(finalMove.r, finalMove.c, PLAYER_AI); 
            const isSingleFourThreat = checkThreateningLine(finalMove.r, finalMove.c, PLAYER_AI); 


            let threatType = null;

            if (!isFinalMoveImmediateWin) { 
                if (isFinalMoveOpenFour) {
                    threatType = 'win_confirmed';
                } 
            }

            if (threatType === null && isSingleFourThreat && !isFinalMoveImmediateWin) { 
                threatType = 'reach';
            }

            // 勝ち確定フラグオン
            if (threatType === 'win_confirmed') {
                // 活四が成立した場合、勝ち確定フラグを立てる
                aiGuaranteedWin = true; // ← 変数名を threatType に合わせました
            }

            if (thinkingIndicator) thinkingIndicator.textContent = ""; 
            
            if (threatType === 'win_confirmed') {
                const winMsg = getRandomMessage('WIN_CONFIRMED');
                updateStatus(winMsg, 'win_confirmed'); 
                // 💡 追加: 勝確メッセージに対応する音声再生
                playVoice(MESSAGE_VOICE_MAP[winMsg], 1.0); 
                await new Promise(resolve => setTimeout(resolve, 800)); 
            } else if (threatType === 'reach') { 
                const reachMsg = getRandomMessage('REACH');
                updateStatus(reachMsg, 'reach'); 
                 // 💡 追加: リーチメッセージに対応する音声再生
                playVoice(MESSAGE_VOICE_MAP[reachMsg], 1.0); 
                await new Promise(resolve => setTimeout(resolve, 800)); 
            }
            
            if (!gameActive) { if (thinkingIndicator) thinkingIndicator.textContent = ""; return; } 

            // ★ 修正2: 脅威ボイスがない AND 次のターンで疲労ボイスがない場合にのみ、ランダム音声再生 ★
            // threatTypeがない かつ、次のターンで「疲労ボイスが再生される予定がない」場合にのみ、AIのランダムな「石を置く音」を再生します。
            if (threatType === null && !willAnnounceFatigueNextTurn) { // ★修正点2: willAnnounceFatigueNextTurn変数を使用
                // 💡 元のロジック: AIが石を置く直前に、30%の確率でランダム音声再生
                playVoice(PUT_VOICES, VOICE_CHANCE_PUT);
            }

            await placePiece(finalMove.r, finalMove.c, PLAYER_AI, threatType);

            if (gameActive) {
                // placePieceでmoveCountが増えている
                const isCurrentFatigued = (moveCount) >= FATIGUE_THRESHOLD; 
                
                // ★ NEW: プレイヤーが勝ち確定状態かをチェック
                // humanThreatTypeを直接参照できないため、現在の盤面から再チェックします
                // プレイヤーの最後の着手は finalMove ではありませんが、ターンが切り替わった直後の盤面を評価します。
                
                // AIのターンが終了し、次にプレイヤーのターンになる直前、
                // プレイヤー側の活四（WIN_CONFIRMED）が続いているかを確認します。
                const humanThreatAfterAITurn = checkThreatsAcrossBoard(PLAYER_HUMAN);

                if (!threatType) {
                    // ★修正: プレイヤーが勝ち確定（WIN_CONFIRMED）の状態でない場合にのみ、表情を戻す
                    if (humanThreatAfterAITurn !== 'WIN_CONFIRMED') {
                        // 脅威がない場合のみ、表情を戻す
                        if (isCurrentFatigued) {
                            // 疲労モードであれば tired に戻す
                            setCharacterMood('tired', 'tired'); // moodTypeを渡すように変更
                        } else {
                            // 非疲労モードであれば smile にする
                            setCharacterMood('smile', 'smile'); // moodTypeを渡すように変更
                        }
                        await new Promise(resolve => setTimeout(resolve, 500)); 
                    } else {
                        // プレイヤーが勝ち確定の状態なら、ピンチ顔を維持するために待機のみ行う
                        await new Promise(resolve => setTimeout(resolve, 500)); 
                    }
                } else {
                    // 脅威がある場合は、表情をリセットしない。(このロジックはそのまま維持)
                    await new Promise(resolve => setTimeout(resolve, 500));
                }
            }
        }
        
        // --- 補助関数 ---

        function isDraw() { 
            return moveCount === BOARD_SIZE * BOARD_SIZE;
        }

        // --- 自動再生制限回避ロジック ---
        let audioContextUnlocked = false;

        function unlockAudio() {
            if (audioContextUnlocked) return;
            
            // Audio Contextが存在する場合、再開を試みる (よりモダンな方法)
            if (window.AudioContext && !window.audioCtx) {
                 window.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }

            if (window.audioCtx && window.audioCtx.state === 'suspended') {
                window.audioCtx.resume().then(() => {
                    console.log("Audio Context resumed successfully.");
                    audioContextUnlocked = true;
                    // 一度解除されたら、イベントリスナーを削除
                    document.removeEventListener('click', unlockAudio, true);
                    document.removeEventListener('touchend', unlockAudio, true);
                    
                    // ★★★ NEW: AudioContextがアンロックされたらBGMの再生も試みる ★★★
                    if (gameBGM && gameBGM.paused && !isMuted && bgmVolume > 0) {
                         gameBGM.play().catch(e => console.warn("BGM play failed after unlock:", e.message));
                    }
                    
                }).catch(e => console.error("Error resuming AudioContext:", e));
                return;
            }

            // 従来のAudio要素を使用した方法 (フォールバック)
            // 無音のAudioオブジェクトを生成して再生し、即時停止する
            // ★ 注: ユーザーが実際に操作するまで、このplay()は失敗することが多いが、
            // ユーザー操作によるオーディオ再生の許可を得るための呼び出しとして残す。
            const url = VOICE_BASE_URL + PUT_VOICES[0];
            const silentAudio = new Audio(url);
            silentAudio.volume = 0; 
            
            silentAudio.play().then(() => {
                console.log("Audio unlocked successfully via silent play.");
                audioContextUnlocked = true;
                // 一度解除されたら、イベントリスナーを削除
                document.removeEventListener('click', unlockAudio, true);
                document.removeEventListener('touchend', unlockAudio, true);
                
                // ★★★ NEW: 従来のAudio要素でのアンロック時もBGMの再生を試みる ★★★
                if (gameBGM && gameBGM.paused && !isMuted && bgmVolume > 0) {
                    gameBGM.play().catch(e => console.warn("BGM play failed after silent unlock:", e.message));
                }
                
            }).catch(e => {
                // console.log("Audio unlock failed, browser still blocking or already unlocked.");
            });
        }

        // ユーザーが最初に操作したときに unlockAudio を実行
        // capture: true で、他のイベントより先にキャッチする
        document.addEventListener('click', unlockAudio, true);
        document.addEventListener('touchend', unlockAudio, true);
        
    </script>
</head>
<body class="bg-gray-100 h-screen flex flex-col items-center justify-start py-2 px-2 font-sans overflow-hidden">
<div id="start-screen" style="display: flex;">
<img alt="タイトル" class="mb-8" id="title-image" src="https://raw.githubusercontent.com/kakinoki-meisaku/gomoku-game/main/assets/images/title.png" style="width: 70vw; max-width: 512px;"/>
<img alt="説明テキスト" class="mb-12 pointer-events-none" id="text-image" src="https://raw.githubusercontent.com/kakinoki-meisaku/gomoku-game/main/assets/images/text.png" style="width: 70vw; max-width: 400px;"/>
<img alt="スタートボタン" class="transition-transform duration-150 ease-in-out transform hover:scale-105 active:scale-95 cursor-pointer" id="start-button" src="https://raw.githubusercontent.com/kakinoki-meisaku/gomoku-game/main/assets/images/start.png" style="width: 45vw; max-width: 300px;"/>
</div>
<div class="w-full h-full relative flex flex-col items-center justify-start" id="game-wrapper">
<canvas id="rainCanvas"></canvas>
<div class="max-w-2xl w-full flex flex-col items-center p-2 relative z-10" id="game-container">
<div class="gradient-polka-dots">
</div>
<div class="flex items-center justify-center space-x-2 w-full pt-1 pb-1 flex-shrink-0">
</div>
<div class="relative flex justify-center px-4 flex-shrink-0" id="character-and-message" style="max-width: min(90vw, 450px); width: 100%; margin: 0 auto; height: 400px; align-items: flex-end; padding-bottom: 0;">
<div class="relative" id="char-image-container">
<img alt="AIキャラクター アメミヤチカ" class="h-auto rounded-lg object-contain relative z-15" id="char-image" src="https://raw.githubusercontent.com/kakinoki-meisaku/gomoku-game/main/assets/images/amemiya_normal.png" style="min-width: 100px;"/>
<img alt="てるしー" id="terushi" src="https://raw.githubusercontent.com/kakinoki-meisaku/gomoku-game/main/assets/images/teru.png" style="position:absolute;bottom:0;left:50%;transform:translateX(-50%);width:200px;z-index:25;display:none;cursor:pointer;animation:float 3s ease-in-out infinite;"/></div>
<div id="audio-control-icon" style="display: none;">
<div id="audio-icon">
<svg class="w-6 h-6 text-gray-700" fill="none" stroke="currentColor" stroke-width="2" viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
<path d="M19.114 5.617a9.28 9.28 0 011.83 4.14M16.896 9.471a5.61 5.61 0 011.11 2.474M14.67 13.327a2.805 2.805 0 01.558 1.237m-2.254-7.854l-4.545 4.545-2.25-2.25-4.5 4.5" stroke-linecap="round" stroke-linejoin="round"></path>
</svg>
</div>
<div id="audio-settings-menu">
<h4 class="text-sm font-bold text-gray-700 mb-1">音声設定</h4>
<div class="flex flex-col">
<label class="text-xs font-semibold text-gray-600" for="bgm-volume-slider">BGM 音量</label>
<input class="w-full" id="bgm-volume-slider" max="100" min="0" type="range" value="20"/>
</div>
<div class="flex flex-col">
<label class="text-xs font-semibold text-gray-600" for="se-voice-volume-slider">効果音・音声 音量</label>
<input class="w-full" id="se-voice-volume-slider" max="100" min="0" type="range" value="80"/>
</div>
</div>
</div>
<div class="absolute z-20 md:w-80 w-[90%] p-3 rounded-xl shadow-2xl transition-colors duration-300 bg-blue-500 text-white shadow-blue-500/80 left-1/2 -translate-x-1/2 bottom-2" id="speech-bubble">
<p class="font-semibold text-sm" id="status-text">対局開始！あなた（黒）のターンです。</p>
<p class="text-sm mt-1" id="timer">持ち時間: 10秒</p>
<div class="w-full h-4 text-center text-white font-bold transition-opacity duration-300 text-xs mt-1" id="thinking-indicator">
</div>
</div>
</div>
<div class="flex w-full justify-center max-w-5xl flex-grow" id="game-area">
<div class="flex flex-col items-center max-w-full justify-center h-full relative" id="board-wrapper">
<div class="board-grid" id="board">
</div>
<div id="reset-button-container" style="display: none;">
<button class="bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-6 rounded-full shadow-lg transition duration-150 ease-in-out transform hover:scale-105 active:scale-95 text-base" id="modal-reset-button">
                            もう一回
                        </button>
</div>
</div>
</div>
</div>
</div>


<script>
// === てるしーギミック Ver.3 ===
let terushiVisible = false;
const terushiElement = document.getElementById('terushi');

// switchTurnフック（プレイヤーターン開始時に出現）
const originalSwitchTurn = window.switchTurn;
if (originalSwitchTurn) {
  window.switchTurn = async function(threatType = null) {
    const result = await originalSwitchTurn.call(this, threatType);
    // プレイヤー（自分）のターンになった直後に出現判定
    if (currentPlayer === PLAYER_HUMAN && gameActive) {
    
		// 1. AIが勝ち確定（aiGuaranteedWin = true）の場合は、てるしーを絶対に出現させない
        if (typeof aiGuaranteedWin !== 'undefined' && aiGuaranteedWin) {
            terushiVisible = false;
            terushiElement.style.display = 'none';
            return result; // 出現処理をスキップして終了
        }
        
        // 2. moveCountが4未満（ゲーム開始直後の数手）の場合は出現させない
        if (typeof moveCount === 'number' && moveCount < 4) {
            terushiVisible = false;
            terushiElement.style.display = 'none';
            return result; // 出現処理をスキップして終了
        }
    
      if (Math.random() < 0.1) {
        terushiVisible = true;
        terushiElement.style.display = 'block';
        if (timerElement) {
          timerElement.innerHTML = '<span class="text-white-500 font-bold text-lg">てるしー出現中！</span>';
        }
      } else {
        terushiVisible = false;
        terushiElement.style.display = 'none';
      }
    }
    return result;
  };
}

// placePiece フック
const originalPlacePiece = window.placePiece;
if (originalPlacePiece) {
  window.placePiece = async function(r, c, player, threatType = null) {
    // テルシー無視
    if (player === PLAYER_HUMAN && terushiVisible) {
      gameActive = false;
      updateStatus('【敗北】てるしーを無視してしまいました…', 'loss');
      // BGMを停止する処理を追加 (★ここを追加)
      stopBGM();
      playVoice(TETU_NG_VOICES, 1.0); // 100%の確率でランダム再生
      // てるしーは表示されたまま
      setTimeout(showResetButton, 2000);
      return;
    }
    
    // ピンチギミック
    // 1. 元の駒を置く処理を実行 (石が盤面に置かれ、勝利判定もここで行われる)
    const result = await originalPlacePiece.call(this, r, c, player, threatType);
    
    // 2. プレイヤー(黒)のターンで、かつゲームが続行中の場合のみ、リーチをチェック
    if (player === PLAYER_HUMAN && gameActive) { 
        // gameActive は元の placePiece 内で勝利した場合は false になっているはず

        // AIの勝ち確フラグが立っている場合、プレイヤーのリーチを無視して処理をスキップ
        if (aiGuaranteedWin) {
            // console.log("AIが勝ち確のため、プレイヤーのリーチによるピンチ顔表示をスキップしました。");
            return result; // 元の処理の結果を返して終了
        }
        //

        const humanThreatType = checkHumanThreats(r, c); 
        if (humanThreatType !== 'NONE') {
            let pinchImageUrl;
            if (humanThreatType === 'WIN_CONFIRMED') {
                // 活四よる勝確時 -> amemiya_pinch01.png
                pinchImageUrl = PINCH_01_URL; 
                playVoice(PINCH_VOICES, 1.0); // 100%の確率でランダム再生
            } else if (humanThreatType === 'REACH') {
                // 単一の四連によるリーチ時 -> amemiya_pinch02.png
                pinchImageUrl = PINCH_02_URL; 
                playVoice(SHOCK_VOICES, 1.0); // 100%の確率でランダム再生
            }
            
            // アメミヤチカの画像を2秒間切り替える
            if (pinchImageUrl) {
                 displayPinchImage(pinchImageUrl); // この関数がピンチ顔を設定する
                // ★ NEW: ピンチ顔が表示されたので、思考中もこの顔を維持するフラグをセット
                isPinchThinking = true;
            }
        }
    }
    return result; // 元の処理の結果を返す
  };
}
// てるしークリックで消す
if (terushiElement) {
  terushiElement.addEventListener('click', () => {
    playVoice(TETU_OK_VOICES, 1.0); // 100%の確率でランダム再生
    terushiVisible = false;
    terushiElement.style.display = 'none';
//     if (timerElement) {
//       timerElement.innerHTML = '残り時間: <span class="text-lg font-extrabold">' + TURN_TIME_LIMIT + '</span> 秒';
//     }
  });
}

// ゲームリセット時のてるしー消去
const originalInitializeGame = window.initializeGame;
if (originalInitializeGame) {
  window.initializeGame = function() {
    //aiGuaranteedWinフラグのリセット
    if (typeof aiGuaranteedWin !== 'undefined') {
            aiGuaranteedWin = false;
        }    
        
    //isPinchThinkingフラグのリセット
        if (typeof isPinchThinking !== 'undefined') {
            isPinchThinking = false;
        }

    if (terushiElement) {
      terushiVisible = false;
      terushiElement.style.display = 'none';
    }
    return originalInitializeGame.call(this);
  };
}
</script>
</body>
</html>