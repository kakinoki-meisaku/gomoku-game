<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>五目並べ (AI アメミヤチカ対戦版)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Tone.jsの読み込み -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <style>
        /* フォント設定 */
        body { font-family: 'Inter', sans-serif; }
        
        /* 盤面コンテナのスタイル */
        .board-grid {
            /* 調整: 碁盤サイズを維持 (最大350px) */
            width: min(80vmin, 350px); 
            height: min(80vmin, 350px);
            aspect-ratio: 1 / 1; 
            background-color: #F8D395; /* 碁盤の色 */
            border: 4px solid #4a2d10;
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.3);
            margin: 0 auto; 
            border-radius: 8px;
            position: relative; 
            
            --interval: calc(100% / 14); 
            
            /* 碁盤の線と天元 (中央の点) の描画 */
            background-image: 
                linear-gradient(to right, #7D4C28 1px, transparent 1px),
                linear-gradient(to bottom, #7D4C28 1px, transparent 1px),
                radial-gradient(circle at center, #7D4C28 4px, transparent 5px); 
            
            background-repeat: repeat, repeat, no-repeat; 
            background-size: var(--interval) var(--interval);
            background-position: 
                0 0, 
                0 0, 
                calc(var(--interval) * 7) calc(var(--interval) * 7); 
        }

        /* 石のスタイル (省略) */
        .cell {
            position: absolute;
            width: 5%; 
            height: 5%;
            cursor: pointer;
            z-index: 10;
        }

        .piece {
            position: absolute;
            width: 90%; 
            height: 90%;
            border-radius: 50%;
            pointer-events: none; 
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.4);
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0); 
            animation: placePiece 0.15s forwards; 
        }

        .piece-black { background-color: #000; }
        .piece-white { background-color: #fff; border: 1px solid #444; }

        @keyframes placePiece {
            from { transform: translate(-50%, -50%) scale(0); }
            to { transform: translate(-50%, -50%) scale(1); }
        }
        
        .last-move {
            box-shadow: 0 0 0 3px rgba(255, 0, 0, 0.8), 0 1px 3px rgba(0, 0, 0, 0.4);
        }
        
        .winning-piece {
            box-shadow: 0 0 10px 4px gold, 0 1px 3px rgba(0, 0, 0, 0.8);
        }

        /* キャラクターとメッセージエリアのスタイル調整 */
        #character-and-message {
            /* キャラクターの高さを300pxに維持 */
            max-width: min(90vw, 450px); 
            width: 100%; 
            margin: 0 auto;
            
            height: 300px; /* キャラクターの存在感を最大化 */
            display: flex; 
            justify-content: center;
            align-items: flex-end; 
            padding-bottom: 0; 
        }
        
        #char-image {
             /* 画像の最大高さをコンテナ内に収める */
            width: 100%; 
            max-height: 300px !important; /* キャラクターの存在感を最大化 */
            object-fit: contain; 
        }

        /* モバイルでのレイアウト調整 */
        @media (max-width: 768px) {
            #character-and-message {
                flex-direction: column; 
                height: auto; 
                max-width: 100%; 
                padding: 0 1rem;
            }
            #char-image {
                max-height: 180px !important; /* モバイルでも少し大きく */
                width: auto !important; 
                margin-top: 10px;
                order: 1; 
            }
            #speech-bubble {
                position: relative !important;
                width: 90% !important;
                transform: none !important;
                margin-top: 10px;
                order: 0; 
            }
        }
    </style>

    <script>
        // ゲーム定数
        const BOARD_SIZE = 15;
        const PLAYER_HUMAN = 1; // 黒 (先手)
        const PLAYER_AI = 2;    // 白 (後手)
        const AI_NAME = "アメミヤチカ"; // AIキャラクター名
        const TURN_TIME_LIMIT = 10; // ターンの制限時間 (秒)
        const TIRED_THRESHOLD = 25; // 25手を超えたら疲労（約13ターン目から）

        // AI評価の重み
        const SCORE_WEIGHTS = {
            0: 0, 1: 1, 2: 10, 3: 100, 4: 1000, 5: 1000000
        };
        // 防御バイアス (今回は1.0)
        const DEFENSE_MULTIPLIER = 1.0; 
        
        // --- キャラクター画像のベースURL ---
        const IMAGE_BASE_URL = "https://raw.githubusercontent.com/kakinoki-meisaku/gomoku-game/main/assets/images/amemiya_";

        // ゲーム状態変数
        let board = [];
        let currentPlayer = PLAYER_HUMAN;
        let gameActive = true;
        let lastMove = null;
        let timerInterval = null;
        let timeRemaining = TURN_TIME_LIMIT;
        let moveCount = 0;
        
        // 見逃し確率を50% (0.5) に設定
        const MISTAKE_PROBABILITY = 0.5;
        // 阻止手と判断するためのスコアボーナス (通常の最大スコアより高い)
        const BLOCK_BONUS = 1500000;
        // 勝利手と判断するための絶対的スコア
        const WIN_SCORE = SCORE_WEIGHTS[5] * 2; // 200万 (勝利手)

        // DOM要素
        let statusElement;
        let boardElement;
        let timerElement;
        let thinkingIndicator;
        let charImageElement;
        let speechBubbleElement; 

        /**
         * 盤面の初期化とUIのセットアップ
         */
        document.addEventListener('DOMContentLoaded', () => {
            speechBubbleElement = document.getElementById('speech-bubble'); 
            statusElement = document.getElementById('status-text');
            timerElement = document.getElementById('timer');
            thinkingIndicator = document.getElementById('thinking-indicator'); 
            charImageElement = document.getElementById('char-image'); 
            boardElement = document.getElementById('board');
            
            initializeBoardUI();
            initializeGame();
            
            document.getElementById('reset-button').addEventListener('click', initializeGame);
        });

        /**
         * ゲーム状態を初期化
         */
        function initializeGame() {
            board = Array(BOARD_SIZE).fill(0).map(() => Array(BOARD_SIZE).fill(0));
            currentPlayer = PLAYER_HUMAN;
            gameActive = true;
            lastMove = null;
            moveCount = 0;
            clearInterval(timerInterval);
            timeRemaining = TURN_TIME_LIMIT;
            
            // 修正: 初期化時に秒数強調スタイルを適用
            if (timerElement) {
                timerElement.innerHTML = `持ち時間: <span class="text-lg font-extrabold">${TURN_TIME_LIMIT}</span> 秒`;
            }
            
            if (thinkingIndicator) thinkingIndicator.textContent = ""; 
            setCharacterMood('normal'); 
            renderGame();
            updateStatus(`対局開始！あなた（黒）のターンです。`);
        }
        
        /**
         * キャラクターの表情を切り替える関数
         * @param {string} mood - 'normal', 'win', 'loss', 'thinking', 'smile', 'reach', 'tired'
         */
        function setCharacterMood(mood) {
            if (!charImageElement) return;

            let suffix = 'normal.png'; 

            if (mood === 'win') {
                suffix = 'win.png'; // AI勝利 (amemiya_win.png)
            } else if (mood === 'loss') {
                suffix = 'lose.png'; // AI敗北 (amemiya_lose.png)
            } else if (mood === 'thinking') {
                suffix = 'think.png'; // AI思考中 (amemiya_think.png)
            } else if (mood === 'smile') {
                suffix = 'smile.png'; // AIが石を置いた (amemiya_smile.png)
            } else if (mood === 'reach') {
                suffix = 'reach01.png'; // AIがリーチ (amemiya_reach01.png)
            } else if (mood === 'tired') {
                suffix = 'tired.png'; // AIが疲労 (amemiya_tired.png)
            }
            
            const path = IMAGE_BASE_URL + suffix;
            
            // 画像が読み込めなかった場合のフォールバック
            charImageElement.onerror = () => {
                charImageElement.src = 'https://placehold.co/160x160/cccccc/333333?text=Char';
            };
            
            charImageElement.src = path;
        }

        // --- (ゲームロジック関数 - 中略) ---
        function initializeBoardUI() {
            if (!boardElement) return;
            boardElement.innerHTML = '';
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    const cell = document.createElement('div');
                    cell.classList.add('cell');
                    cell.dataset.row = r;
                    cell.dataset.col = c;
                    
                    const interval = 100 / (BOARD_SIZE - 1);
                    const leftPos = c * interval; 
                    const topPos = r * interval;
                    
                    cell.style.left = `${leftPos}%`;
                    cell.style.top = `${topPos}%`;
                    cell.style.transform = 'translate(-50%, -50%)'; 
                    
                    cell.addEventListener('click', () => handleCellClick(r, c));
                    boardElement.appendChild(cell);
                }
            }
        }
        
        function renderGame() {
            if (!boardElement || !timerElement || !thinkingIndicator) return;

            const cells = boardElement.querySelectorAll('.cell');
            cells.forEach(cell => {
                const r = parseInt(cell.dataset.row);
                const c = parseInt(cell.dataset.col);
                const player = board[r][c];

                cell.innerHTML = ''; 
                
                if (player !== 0) {
                    const piece = document.createElement('div');
                    piece.classList.add('piece', player === PLAYER_HUMAN ? 'piece-black' : 'piece-white');
                    
                    if (lastMove && lastMove.r === r && lastMove.c === c) {
                        piece.classList.add('last-move');
                    }
                    
                    cell.appendChild(piece);
                }
            });

            if (!gameActive && lastMove) {
                if (checkWin(lastMove.r, lastMove.c, lastMove.player)) {
                    highlightWinningLine(lastMove.r, lastMove.c, lastMove.player);
                }
            }

            if (gameActive) {
                clearInterval(timerInterval);
                if (currentPlayer === PLAYER_HUMAN) {
                    thinkingIndicator.textContent = ""; 
                    if (moveCount > 0) { 
                        startTimer();
                    } else {
                        // 最初の1手は時間無制限
                        timerElement.innerHTML = "最初の1手は時間無制限です";
                    }
                } else {
                    timerElement.innerHTML = `${AI_NAME}のターン`; 
                    // gameActiveをチェックしてからAIのターンを開始
                    setTimeout(() => { if (gameActive) aiTurn(); }, 500); 
                }
            }
        }
        
        function startTimer() {
            if (!timerElement || !speechBubbleElement) return;

            timeRemaining = TURN_TIME_LIMIT;
            
            const statusDiv = speechBubbleElement;
            // 既存の警告色とアニメーションを削除
            statusDiv.classList.remove('bg-red-400', 'bg-red-500', 'bg-red-600', 'shadow-red-400/80', 'shadow-red-500/80', 'shadow-red-600/80', 'animate-pulse');
            // ノーマルカラーである青を強制的に設定し、タイマースタート
            statusDiv.classList.add('bg-blue-500', 'shadow-blue-500/80'); 


            timerInterval = setInterval(() => {
                timeRemaining--;
                
                // 修正: 秒数部分のみを大きく、太字の白文字で表示 (赤色警告は適用しない)
                timerElement.innerHTML = `残り時間: <span class="text-lg font-extrabold">${timeRemaining}</span> 秒`;

                // メッセージボックスの色クラスをリセット（テキスト色はベースクラスで維持される）
                statusDiv.classList.remove('bg-red-400', 'bg-red-500', 'bg-red-600', 'shadow-red-400/80', 'shadow-red-500/80', 'shadow-red-600/80', 'animate-pulse');
                statusDiv.classList.remove('bg-blue-500', 'shadow-blue-500/80'); // 青も毎回リセットする

                if (timeRemaining <= 0) {
                    clearInterval(timerInterval);
                    handleTimeOut();
                } else if (timeRemaining <= 3) {
                    // 3秒以下：メッセージボックスの色を段階的に赤くする (タイマーテキストは白のまま)
                    if (timeRemaining === 3) {
                        statusDiv.classList.add('bg-red-400', 'shadow-red-400/80');
                    } else if (timeRemaining === 2) {
                        statusDiv.classList.add('bg-red-500', 'shadow-red-500/80');
                    } else if (timeRemaining === 1) {
                        statusDiv.classList.add('bg-red-600', 'shadow-red-600/80', 'animate-pulse');
                    }
                } else {
                     // 4秒以上の場合は青を維持
                     statusDiv.classList.add('bg-blue-500', 'shadow-blue-500/80'); // 青を確実に再設定
                }
            }, 1000);
        }

        function handleTimeOut() {
            gameActive = false;
            if (thinkingIndicator) thinkingIndicator.textContent = ""; 
            // 人間プレイヤーの敗北（AIの勝利）
            updateStatus(`【時間切れ】10秒以内に石を置けませんでした。${AI_NAME}（白）の勝ちです！`, 'loss'); 
        }

        function handleCellClick(r, c) {
            if (!gameActive || currentPlayer !== PLAYER_HUMAN) return;
            // 人間がクリックした時点で思考中メッセージをクリア
            if (thinkingIndicator) thinkingIndicator.textContent = "";

            if (board[r][c] === 0) {
                clearInterval(timerInterval);
                placePiece(r, c, PLAYER_HUMAN);
            }
        }

        function placePiece(r, c, player) {
            board[r][c] = player;
            lastMove = { r, c, player };
            moveCount++;

            // 石を置いた後、思考中メッセージを必ずクリア
            if (thinkingIndicator) thinkingIndicator.textContent = ""; 

            if (checkWin(r, c, player)) {
                gameActive = false;
                const winnerText = player === PLAYER_HUMAN ? `あなた（黒）` : `${AI_NAME}（白）`; 
                // playerがHumanなら'win'（AIの敗北）、AIなら'loss'（AIの勝利）を渡す
                const statusType = player === PLAYER_HUMAN ? 'win' : 'loss';
                updateStatus(`【勝利】${winnerText}の勝ちです！`, statusType);
                renderGame(); 
            } else if (isDraw()) {
                gameActive = false;
                updateStatus(`【引き分け】碁盤がすべて埋まりました。`, 'draw');
                renderGame(); 
            } else {
                // 勝敗が決まらなければターンを切り替える
                switchTurn();
            }
        }

        function switchTurn() {
            currentPlayer = currentPlayer === PLAYER_HUMAN ? PLAYER_AI : PLAYER_HUMAN;
            renderGame();
            
            const turnText = currentPlayer === PLAYER_HUMAN ? `あなた（黒）` : `${AI_NAME}（白）`; 
            const isTired = moveCount >= TIRED_THRESHOLD;
            let message = `${turnText}のターンです。`;

            if (gameActive) {
                if (currentPlayer === PLAYER_AI) {
                    // AIのターン
                    if (isTired) {
                        // 待機中は疲労表情
                        setCharacterMood('tired');
                        message = "（ふぅ...）少し疲れてきました。集中しなくては。";
                    } else {
                        setCharacterMood('normal');
                    }
                } else {
                    // 人間（黒）のターン
                    if (isTired) {
                        // 疲労状態を確実に維持 
                        setCharacterMood('tired'); 
                        message = `${AI_NAME}は疲れているようですが、あなたのターンです。`; 
                    } else {
                        setCharacterMood('normal');
                    }
                }
            } else {
                 // ゲーム終了時は通常表情に戻す
                setCharacterMood('normal');
            }
            
            // updateStatusの呼び出しは変えずに、messageとtypeを渡す
            updateStatus(message, 'normal');
        }
        
        /**
         * ステータス表示の更新
         * @param {string} message - 表示メッセージ
         * @param {string} type - 'normal', 'win' (人間勝利), 'loss' (人間敗北), 'draw', 'reach', 'tired'
         */
        function updateStatus(message, type = 'normal') {
            // DOM要素が存在しない場合は処理を中断 (エラー対策)
            if (!statusElement || !speechBubbleElement) return; 
            
            statusElement.textContent = message;
            
            const statusDiv = speechBubbleElement;
            // クラスをリセットし、ベースとして白い文字を確実に設定
            statusDiv.className = 'absolute z-20 md:w-80 w-[90%] p-3 rounded-xl shadow-2xl transition-colors duration-300 left-1/2 -translate-x-1/2 bottom-2 text-white';
            
            // 特殊な場合のみ色を設定
            if (type === 'win') { // 人間プレイヤーの勝利 (AIの敗北)
                statusDiv.classList.add('bg-green-500', 'shadow-green-500/80'); 
                setCharacterMood('loss'); // AIは敗北表情
            } else if (type === 'loss') { // 人間プレイヤーの敗北 (AIの勝利)
                statusDiv.classList.add('bg-red-500', 'shadow-red-500/80');
                setCharacterMood('win'); // AIは勝利表情
            } else if (type === 'draw') {
                // 引き分け時のみ文字色をグレーにする
                statusDiv.classList.remove('text-white');
                statusDiv.classList.add('bg-yellow-400', 'text-gray-800', 'shadow-yellow-400/80');
                setCharacterMood('normal');
            } else if (type === 'reach') {
                // リーチメッセージ
                statusDiv.classList.add('bg-pink-500', 'shadow-pink-500/80');
                setCharacterMood('reach');
            } else if (type === 'tired') { // NEW: 疲労時の弱体化メッセージ
                statusDiv.classList.add('bg-orange-500', 'shadow-orange-500/80');
                setCharacterMood('tired');
            } else {
                // 'normal' の場合 (初期状態やターン切り替え時) は青を設定
                statusDiv.classList.add('bg-blue-500', 'shadow-blue-500/80');
                // ここでは表情を変更しない (switchTurnまたはaiTurnで制御済み)
            }
        }

        async function aiTurn() {
            if (!gameActive) { if (thinkingIndicator) thinkingIndicator.textContent = ""; return; } 

            // 1. 思考開始 
            if (thinkingIndicator) thinkingIndicator.textContent = "思考中..."; // アメミヤチカの名前を削除
            
            // 疲労状態に関わらず、思考中は 'thinking' に切り替える
            setCharacterMood('thinking'); 

            // 思考時間シミュレーション
            await new Promise(resolve => setTimeout(resolve, 800 + Math.random() * 500)); 
            
            if (!gameActive) { if (thinkingIndicator) thinkingIndicator.textContent = ""; return; } 

            // 修正された findBestMove を使用
            const scoredMoves = findBestMove(PLAYER_AI);
            
            // findBestMoveは常にソートされた配列を返す
            let bestMove = scoredMoves[0]?.move;
            const isTired = moveCount >= TIRED_THRESHOLD;
            const topScore = scoredMoves[0]?.score || 0; 
            
            // トップスコアが勝利手（200万以上）か
            const isWinMove = topScore >= WIN_SCORE;
            // トップスコアが阻止手（150万以上200万未満）か
            const isBlockMove = topScore >= BLOCK_BONUS && topScore < WIN_SCORE;
            // トップスコアが通常の攻防（150万未満）か
            const isNormalMove = topScore < BLOCK_BONUS;
            
            if (scoredMoves.length > 0) {
                
                let shouldWeaken = false;
                
                // 1. 勝利手は絶対に見逃さない
                if (isWinMove) {
                    shouldWeaken = false;
                }
                // 2. 阻止手の場合 (疲労時のみ MISTAKE_PROBABILITY=0.5 で逃す)
                else if (isBlockMove && isTired) {
                    if (Math.random() < MISTAKE_PROBABILITY) {
                        shouldWeaken = true; // 50%の確率で弱体化
                    }
                } 
                // 3. 通常の手の場合 (疲労時のみ MISTAKE_PROBABILITY=0.5 で逃す)
                else if (isNormalMove && isTired) { 
                    if (Math.random() < MISTAKE_PROBABILITY) {
                        shouldWeaken = true; // 50%の確率で弱体化
                    }
                }
                
                // --- 弱体化実行ロジック ---
                if (shouldWeaken) { 
                    // 弱体化処理：トップ3のムーブから、ベストムーブを除いた1番目か2番目のムーブを選択
                    // scoredMovesは最低でも1つ以上のムーブを含んでいるはずだが、安全のためチェック
                    const topMoves = scoredMoves.slice(0, Math.min(3, scoredMoves.length));

                    if (topMoves.length > 1) {
                        // トップムーブ（最善手）を除いた、2番目か3番目の手をランダムに選ぶ
                        const weakerMoves = topMoves.slice(1); 
                        const randomIndex = Math.floor(Math.random() * weakerMoves.length);
                        bestMove = weakerMoves[randomIndex].move;
                    } else {
                        // 候補手が1つしかない場合は、そのままそのムーブを使う (最善手)
                        bestMove = topMoves[0].move; 
                    }

                    // 阻止を見逃した時の特別なメッセージ表示
                    if (isBlockMove) {
                        updateStatus("（疲労で集中力が...）大事な手を見逃したかも。", 'tired'); 
                        // メッセージを少し長く見せるため待機
                        await new Promise(resolve => setTimeout(resolve, 800)); 
                    }

                } else {
                    // 弱体化しない場合は、常にベストムーブ
                    bestMove = scoredMoves[0].move;
                }
                // ---------------------------------------------
                
                // Resetチェック
                if (!gameActive) { if (thinkingIndicator) thinkingIndicator.textContent = ""; return; } 

                // 2. リーチ判定と表情/メッセージ更新 (AIが選択した 'bestMove' で判定)
                board[bestMove.r][bestMove.c] = PLAYER_AI; 
                // 置く場所が勝利手になるかチェック (即座の勝利)
                const isImmediateWin = checkWin(bestMove.r, bestMove.c, PLAYER_AI); 
                // 置く場所が強力なリーチ手になるかチェック (活四以上)
                const isStrongThreat = checkThreateningLine(bestMove.r, bestMove.c, PLAYER_AI);
                board[bestMove.r][bestMove.c] = 0; // 盤面を元に戻す

                if (thinkingIndicator) thinkingIndicator.textContent = ""; // 石を置く前に思考中をクリア
                
                // 即座の勝利ではないが、強力な脅威（活四以上のリーチ）をかけた場合
                if (!isImmediateWin && isStrongThreat && !isBlockMove) { 
                    updateStatus("チェック！次の手で決まりそうです。", 'reach'); 
                    // Reach表情はupdateStatusで設定される
                    await new Promise(resolve => setTimeout(resolve, 800)); // リーチ表情を短時間維持
                }
                
                // Resetチェック
                if (!gameActive) { if (thinkingIndicator) thinkingIndicator.textContent = ""; return; } 


                // 3. 石を置く
                placePiece(bestMove.r, bestMove.c, PLAYER_AI);
                
                // 4. スマイル（着手時）表示 (ゲームが続行している場合のみ)
                if (gameActive) {
                    
                    if (!isTired) {
                        // 疲労閾値未満の場合のみスマイルを一時的に表示する
                        setCharacterMood('smile');
                        await new Promise(resolve => setTimeout(resolve, 500)); // 0.5秒スマイル維持
                    }
                    
                    // ターン切り替え前に、疲労状態に応じて表情を再設定 (待機表情に戻る)
                    if (isTired) {
                        setCharacterMood('tired'); // 疲れていればtiredに戻す
                    } else {
                        setCharacterMood('normal'); // 疲れていなければnormalに戻す
                    }
                }
                
                // placePiece内でswitchTurnが呼ばれるため、ここでは不要
            } else {
                if (thinkingIndicator) thinkingIndicator.textContent = "";
                switchTurn(); 
            }
        }
        
        // --- AIロジック関数 (勝利/阻止の絶対的な優先順位を保証するために修正) ---
        function findBestMove(player) {
            const availableMoves = getAvailableMoves(); 
            const opponent = player === PLAYER_HUMAN ? PLAYER_AI : PLAYER_HUMAN; 
            const scoredMoves = [];

            // 1. 即座の勝利判定 (最優先)
            for (const move of availableMoves) {
                const { r, c } = move;
                board[r][c] = player;
                if (checkWin(r, c, player)) { 
                    board[r][c] = 0; 
                    // 勝利手を見つけたら、即座にそれを返す（100%実行）
                    return [{ move, score: WIN_SCORE }]; 
                }
                board[r][c] = 0; 
            }

            // 2. 勝利手がない場合、すべての候補手をスコアリング
            for (const move of availableMoves) {
                const { r, c } = move;
                let score = 0;
                let isImmediateBlock = false;

                // 2.1 相手の即座の勝利阻止判定
                board[r][c] = opponent; 
                if (checkWin(r, c, opponent)) { 
                    isImmediateBlock = true;
                }
                board[r][c] = 0; 
                
                // 2.2 通常評価
                board[r][c] = player; 
                const currentScore = evaluateBoard(player); // 自分の攻め
                board[r][c] = 0; 

                board[r][c] = opponent; 
                const opponentScore = evaluateBoard(opponent); // 相手の攻めに対する守り
                board[r][c] = 0;

                // 通常スコアを計算
                score = currentScore + opponentScore * DEFENSE_MULTIPLIER;
                
                // 2.3 阻止手であれば、スコアをブースト（トップに来るが、他の手も配列に残る）
                if (isImmediateBlock) {
                    score += BLOCK_BONUS;
                }

                scoredMoves.push({ move, score });
            }
            
            // 3. スコア順にソートして、すべてを返す
            scoredMoves.sort((a, b) => b.score - a.score);
            
            return scoredMoves; 
        }

        // AIが探索する候補手を見つけるロジックは、すべての空きマスをチェック
        function getAvailableMoves() {
            const moves = [];
            let hasPlacedPieces = false;
            
            // 盤面の全てのマスをチェック
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    if (board[r][c] !== 0) {
                        hasPlacedPieces = true;
                    } else {
                        // 空きマスはすべて候補とする
                        moves.push({ r, c });
                    }
                }
            }
            
            // 最初の1手の場合のみ、中央に限定
            if (!hasPlacedPieces && moves.length > 0) {
                 return [{ r: 7, c: 7 }]; 
            }
            // それ以外の場合は、すべての空きマスを返す（勝利手を見逃さないため）
            return moves;
        }

        function checkThreateningLine(r, c, player) {
            const directions = [[0, 1], [1, 0], [1, 1], [1, -1]]; 
            const opponent = player === PLAYER_HUMAN ? PLAYER_AI : PLAYER_HUMAN;

            for (const [dr, dc] of directions) {
                for (let offset = -4; offset <= 0; offset++) {
                    let friendlyCount = 0;
                    let emptyCount = 0;
                    let blocked = false;
                    
                    for (let k = 0; k < 5; k++) {
                        const nr = r + dr * (k + offset);
                        const nc = c + dc * (k + offset);
                        
                        if (nr < 0 || nr >= BOARD_SIZE || nc < 0 || nc >= BOARD_SIZE) { continue; }

                        const currentVal = board[nr][nc];
                        if (currentVal === opponent) { blocked = true; break; } 
                        else if (currentVal === player) { friendlyCount++; } 
                        else if (currentVal === 0) { emptyCount++; }
                    }
                    if (blocked) continue;
                    
                    // 4連（活四）のみをリーチとして扱う
                    if (friendlyCount === 4 && emptyCount >= 1) { return true; }
                }
            }
            return false;
        }
        
        function evaluateBoard(player) {
            let totalScore = 0;
            const directions = [[0, 1], [1, 0], [1, 1], [1, -1]]; 

            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    if (board[r][c] !== 0) continue; 

                    for (const [dr, dc] of directions) {
                        totalScore += getLineScore(r, c, dr, dc, player);
                    }
                }
            }
            return totalScore;
        }
        function getLineScore(r, c, dr, dc, player) {
            let score = 0;
            const consecutive1 = countConsecutive(r, c, dr, dc, player);
            const consecutive2 = countConsecutive(r, c, -dr, -dc, player);
            const maxConsecutive = consecutive1 + consecutive2 + 1; 
            
            if (maxConsecutive >= 5) { return SCORE_WEIGHTS[5]; } // 勝利のラインだが、評価時は 100万 に留まる
            if (maxConsecutive >= 1) { score += SCORE_WEIGHTS[maxConsecutive] || 0; }
            return score;
        }
        function countConsecutive(r, c, dr, dc, player) {
            let count = 0;
            for (let k = 1; k < BOARD_SIZE; k++) {
                const nr = r + dr * k;
                const nc = c + dc * k;
                if (nr >= 0 && nr < BOARD_SIZE && nc >= 0 && nc < BOARD_SIZE && board[nr][nc] === player) { count++; } else { break; }
            }
            return count;
        }
        function checkWin(r, c, player) {
            const directions = [[0, 1], [1, 0], [1, 1], [1, -1]]; 
            for (const [dr, dc] of directions) {
                if (countConsecutive(r, c, dr, dc, player) + 1 + countConsecutive(r, c, -dr, -dc, player) >= 5) {
                    return true;
                }
            }
            return false;
        }
        function highlightWinningLine(r, c, player) {
            const directions = [[0, 1], [1, 0], [1, 1], [1, -1]]; 
            for (const [dr, dc] of directions) {
                const count1 = countConsecutive(r, c, dr, dc, player);
                const count2 = countConsecutive(r, c, -dr, -dc, player);
                
                if (count1 + 1 + count2 >= 5) {
                    let startR = r - dr * count2;
                    let startC = c - dc * count2;
                    const length = count1 + count2 + 1;

                    for (let i = 0; i < length; i++) {
                        const cellElement = boardElement.querySelector(`[data-row="${startR + dr * i}"][data-col="${startC + dc * i}"]`);
                        const pieceElement = cellElement ? cellElement.querySelector('.piece') : null;
                        if (pieceElement) { pieceElement.classList.add('winning-piece'); }
                    }
                    return; 
                }
            }
        }
        function isDraw() {
            return board.flat().filter(p => p !== 0).length === BOARD_SIZE * BOARD_SIZE;
        }
    </script>
</head>
<!-- body に h-screen と overflow-hidden を追加し、スクロールを無効化 -->
<body class="bg-gray-100 h-screen flex flex-col items-center justify-start py-2 px-2 font-sans overflow-hidden">

    <!-- game-container は画面の高さをフルに使い、白背景を適用 -->
    <div id="game-container" class="max-w-4xl w-full flex flex-col items-center p-2 bg-white rounded-xl shadow-2xl h-full">
        <!-- 1. タイトルエリア (flex-shrink-0で固定) -->
        <div class="flex items-center justify-center space-x-2 w-full pt-1 pb-1 flex-shrink-0">
            <!-- タイトルにAIキャラ名を反映 -->
            <h1 class="text-xl font-extrabold text-center text-gray-800">五目並べ (AI アメミヤチカ対戦版)</h1>
        </div>
        
        <!-- 2. キャラクターとメッセージエリア (flex-shrink-0で固定) -->
        <div id="character-and-message" class="relative flex justify-center px-4 flex-shrink-0">
            
            <!-- キャラクター画像 (シャドウを削除し、透過を活かす) -->
            <img id="char-image" 
                src="https://raw.githubusercontent.com/kakinoki-meisaku/gomoku-game/main/assets/images/amemiya_normal.png" 
                alt="AIキャラクター アメミヤチカ" 
                class="h-auto rounded-lg object-contain relative z-10"
                style="min-width: 100px;">

            <!-- セリフボックス (Z-20, キャラクターに重ねる) -->
            <div id="speech-bubble" 
                 class="absolute z-20 md:w-80 w-[90%] p-3 rounded-xl shadow-2xl transition-colors duration-300
                 bg-blue-500 text-white shadow-blue-500/80
                 left-1/2 -translate-x-1/2 bottom-2">
                <p id="status-text" class="font-semibold text-sm">対局開始！あなた（黒）のターンです。</p>
                <!-- JSでinnerHTMLを書き換えるため、ここではシンプルなクラスを設定 -->
                <p id="timer" class="text-sm mt-1">持ち時間: 10秒</p>
                <!-- AI思考中表示エリア -->
                <div id="thinking-indicator" class="w-full h-4 text-center text-white font-bold transition-opacity duration-300 text-xs mt-1">
                </div>
            </div>
        </div>

        <!-- 3. メインゲームエリア：盤面を中央に配置 -->
        <!-- flex-grow を使用し、残りの高さをすべて占有させる (最も重要なエリア) -->
        <div id="game-area" class="flex w-full justify-center max-w-5xl flex-grow">
            
            <!-- 盤面エリア (中央) -->
            <div id="board-wrapper" class="flex flex-col items-center max-w-full justify-center h-full">
                <!-- 盤面本体 -->
                <div id="board" class="board-grid">
                    <!-- 交点セルはJavaScriptで生成されます -->
                </div>
            </div>
        </div>

        <!-- 4. コントロールエリア (flex-shrink-0で固定) -->
        <div class="flex justify-center w-full py-3 flex-shrink-0">
            <button id="reset-button" class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-6 rounded-full shadow-lg transition duration-150 ease-in-out transform hover:scale-105 active:scale-95 text-sm">
                リセット
            </button>
        </div>
    </div>
</body>
</html>
